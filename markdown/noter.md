<link type="text/css" rel="stylesheet" href="/css/style.css">
```
/* 付国宏： 培养兴趣、专注、坚持
 * deeep learning
 *
 * 16/9/7/下午NLP meet
 */
 ```
---

# 日常笔记
### OOP：面向对象编程
- 虽然在大规模的问题中（像高考分数分布）往往体现出正态分布，但是，我认为，我们不能在解决实际问题之前就先验的假定并认为其符合XX分布。我认为这正好是‘概率模型的最大问题’。
- 同样，我们也不能在解决问题之前就假定并认为可以用OOP建模。我认为OOP思想来源于自然界的动植物分类以及以对象的方式进行抽象。问题在于：动植物分类手册可以只有分析，而没有综合。而我们的软件系统必然包含{分析，综合}两种方法。类别之间可以没有交互吗？可以的话我们就可以不用联系的观点看问题了。
- 编程的真正难点在于：抽象化。原因：抽象的的概念往往与显而易见的实际大相径庭。人本身很难进行大规模的抽象化{记忆力和计算力的缺陷：这样看人类确实是感性动物}。
- 真正驱动语言发展的关键是什么？简单性+性能
	- C++，java，python，ruby：库越來越强大，代码量越來越小。
	- C，C++，julia，rust：没有对象的C，复杂的C++，没有冗余的rust。有的都是性能优势。
- 复杂性原则：我们没有办法让一个复杂问题变简单，因为我们不能改变问题的复杂度，除了偷换问题。但我们可以把复杂的问题带给我们的困扰降低，至少在一定的时间内降低（摊平）。
- 库和框架的区别：库是一堆工具。框架是一架机器。
- 编程真正的要害在于：抽象+封装
- 正则表达式在处理**结构化文本**时，用起来很方便：URL，HTML，。。。
- 
### other
- 书本解决不了发展中国家的问题
- 人们面临的两难困境
![](pict/末代皇帝.png)
- 程度越大,矛盾越深
![](pict/欧洲穆斯林化.png)
- 欧洲对能源的依赖
![](pict/欧洲油气管网.png)
- 文明的说话,委婉的语气
- 所受的教育到底在学什么?
![](pict/奇怕.png)
- 结果的重要性  
![](pict/任劳任怨.png)
- 资源的消耗:   
![](pict/食肉.png)
- 弗如凝滞:   
![](pict/体脂率.png)
---
- 城市的生活成本为什么高企?
	- 工业生产+市场竞争=>低廉的商品售价
	- 中产的收入明显高于底层.
	- 收入多花的少? 钱去哪了?
- 似乎我们都是被外部定义的?因为内部意义只有自己知道,

---

生命之光：
在一个生命有机体的空间范围内，在空间上和时间上发生的事件，如何用物理学和化学来解释？
	当前的物理学和化学在解释这些问题时明显的无能为力，
		决不是成为怀疑这些事件可以用物理学和化学来解释的理由
	如果说过去的碌碌无为只是意味着激起未来获得成功的希望，
		那未免太轻描淡写了。它有着更为积极的意义，
	无生命的 自然界已经使得物理学家穷于应付了
	【有规律的物质结构  和   无规律的物质结构】
	然而对我们自身来说，最感兴趣的唯一的一件事是：我 们在感觉、思维和知觉。
	在生命有机体中起重要作用的所有物理学和化学的定律都是这种统计学的定律
	磁场要产生的取向不断地遭到随机取向的热运动的对抗
	偏差将是根号n这一级。
		因此，如果数目n＝100，你将发现 偏差大约是10，于是相对误差＝10%。
		可是，如果n=1000000，你多半会发现偏差大约是1000，相对误差＝0.1%
	人有48个染色体
		平均只要50或60次连续的 分裂，便足以产生出一个成人的细胞数，
		或者是这个细胞数的十倍，那就是把一生中细胞的更替也考虑在内了
	变幻无常的现象徘徊着，你将定于永恒的思想。——歌德
	细微的、连续的变异不是遗传的，所以选择没有效果。
		即使是完全纯种繁育的原种的后代里，也有极少数的个体，
		比如说几万分之二、三，出现了细微的但是“跃迁式”的变化
		德弗里斯称之为突变。重要的事实是不连续性
	频繁的突变对进化是有害的
	要摆脱死亡，就是说要活着，唯一的办法就是从环境里不断地汲取负熵
	在温度处于绝对零度时（大约在-273℃），任何一种物体的熵等于零
	如果一个人从不自相矛盾的话，一定是因为他从来什么也不说。——乌那木诺
	
语言学习的临界期：
	 关于语言的临界期会一直持续到五六岁，
	 所以如果想让自己的孩子学会分辨L和R的区别，
	 可以让孩子在平时多听英语（以英语为母语的人说的英语）。
	 脑内地图根据那之后的环境、经历，是能够改变的，
	 那要根据父母想把孩子培养成什么样的人而定。不过，事情不限于英语。
	 “听不见、看不见”的环境会使回路消失，
	 而“听得见、看得见”的环境则能够培养那种能力，这便是大脑学习的理论。
     因此，在学习语言的临界期如果处于完全不接触语言的环境，
	 就会变得无法理解语言。
	 例如'1920年在印度的深山中发现了被狼养育大的名叫卡马拉的少女，
	 她从8岁（估计）被发现到9年后去世之间，
	 虽然运动机能以及感觉功能得到了恢复．
	 但需要进行更高级的脑内信息处理的语言功能并没有改善，
	 一直到最后都不会说话。因此'让孩子置身于信息量大，
	 而且均衡的环境中非常重要。在学会分辨L和R的差异以前，
	 能听到“别人说话”的环境可以培养孩子的语言能力以及感受性，这一点不能忘记。
     不论是什么语言，小孩通过听到别人跟他说话，
	 了解在这个世界上有语言这种事物。即便还不能回答，但对那个婴儿来说，
	 跟他说话，是他通往“语言的世界”的重要入口。
    对于小孩来说，训练自己讲话的是从一生下来就陪伴自己的父母以及身边的人。
    婴儿在大脑发育的初期能在多大程度上理解父母等人所说的话，
	这一点还不是很清楚。不过，最近弄明白了一点，那就是，
	在6个月以前婴儿只是将说话时的声音作为声音来理解，
	而到6个月左右，变得可以将那作为“语言”来理解，对于母语开始显示特别的反应。
     另外，关于视觉的临界期从出生后10个月左右开始。在那个时候，
	 婴儿会去看凝视自己、跟自己说话时的父母的“嘴的动作”。
	 婴儿将父母说话时的口形作为模仿对象记忆在脑海里，
	 而且那些记忆在逐个理解事物以及动作的意义的过程中，
	 起着与意义对应的庞大数据库的作用。不用说，“搭讪”可以使孩子情绪安定，
	 建构起亲子的信赖关系。
	 另外，从完全还不会说话的时候开始学习语言的观点来看，
	 那也是非常有效的方法。不要认为“反正跟他说也听不明白”。
	 凝视婴儿的眼睛，尽量以笑容来面对，开心地“搭讪”，这样做是很重要的。
     从父母那样的行为中，婴儿开始知道人是会说话的动物，
	 可以通过语言与别人进行交流。而且，大脑在一步一步地为说话做准备，
	 逐渐形成了与交流相关的回路，
	 例如自己说话、听人说话，关爱别人、帮助别人等。
     相反，在完全没有语言的环境中，即不存在人与人相互交流的环境中，
	 小孩的语言能力以及交际能力绝对得不到培养。在没有语言的环境中长大的孩子，
	 即便在听说时所需的耳膜或声带没有问题，也听不懂、说不出话。
	 更准确地说，将无法理解语言的存在。
     小孩在模仿父母说话时的口形的过程中，学会把嘴巴张大时发出的是“啊”的声音，
	 把嘴巴拉开时发出的是“衣”的声音等等。
	 另一方面，小孩在模仿大人等“他人”所做的各种各样的动作过程中，
	 逐渐学会“那个动作有意义”这些事情。而且，那对学习语言来说，
	 具有根本性意义。
     例如，在“自己用塑料杯喝牛奶”和“爸爸用玻璃杯喝啤酒”时，牛奶和啤酒、
	 塑料杯和玻璃杯显然是不同的。
	 但是，孩子会逐渐认识到“喝”这一动作基本上没有什么两样，
	 因而将自己的动作和爸爸的动作逐渐“认定为一种动作”。也就是说，
	 乍看不同的自己和爸爸的“喝”的动作是指将液体倒人口内，
	 从口内吞下去的行为。
	 通过将细节上各不相同的具体的事项和“喝”这个词语连接起来，
	 才能将那个动作“概念化”、“抽象化”。
     而且，在能够理解“喝”这个动作的意义的时候，小孩逐渐能够理解：
	 虽然自己所使用的塑料杯和父亲所使用的玻璃杯完全不同，但起着同样的作用。
	 也就是说，小孩能够认识到所使用的东西即便材料、形状、颜色不同，
	 但都是“用来喝某种东西的餐器=杯子”，也能够正确地理解“杯子”这个词的意思。
    因此，“理解动作”在学习语言时是极为重要的，
	在喝东西时候使用的容器叫做“杯子”，
	在做“投”、”踢”这些动作时所使用的圆形的东西不论是棒球、足球，都叫做“球”。
	那样一来，小孩不仅能将词语用于眼前的东西，还能用于独立的“概念”。

大脑如何简历道德观念？
有多少个性源于遗传？

奇点:{    odd point
		  数学:无限小且不实际存在的“点” 
		  物理:    时空无限弯曲的那一个点 
		  宇宙:既存在又不能描述的一点 
}
意识(1):是人脑对大脑内外表象的觉察。
		生理学上，意识脑区指可以获得其它各脑区信息的意识脑区（在前额叶周边）。
		意识脑区最重要的功能就是辨识真伪，
		即它可以辨识自己脑区中的表象是来自于外部感官的还是来自于想像或回忆的。
		此种辨识真伪的能力，任何其它脑区都没有.
	  (2):意识为一种特殊而复杂的运动.意识是因脑内神经活动而产生
	  意，既是自我的意思。识，就是认知，认识。意识，代表个体的独立性，它是主观存在的独特坐标。
	  	意识，代表了人可以认识自己的存在，可以知道发生的事情。
	  	可以对立与不同于自己的存在进行对比。意识的定义非常简单，就是认识和知道事物的存在的那个。
	  	意识本来就是精神同一种用法。
大脑的神经存储单元也称作记忆细胞，占大脑神经细胞总量的20%左右。
	通常人类特有的意识被称之为：思想。
	[意:听到了你说的话.识:识别,明白你说的话语的意思]
*
*
如何让机器拥有自我意识?(如何证明自我的存在?)
*
*
知识图谱（Knowledge Graph/Vault）又称为科学知识图谱，
	在图书情报界称为知识域可视化或知识领域映射地图，
	是显示知识发展进程与结构关系的一系列各种不同的图形，
	用可视化技术描述知识资源及其载体，挖掘、分析、构建、绘制和显示知识及它们之间的相互联系。
奥卡姆剃刀:“如无必要，勿增实体” （Entities should not be multiplied unnecessarily）

最小二乘法:
模拟退火
命题逻辑
一阶逻辑
自然演绎
特征工程
分布式学习
增量学习
动态规划
约束规划
逻辑程序
自动规划
局域回归
生成模型
辨别模型
核方法
矩阵分解
框架问题
决策树
随机森林
KNN学习
TFIDF
LDA
卷积滤波
二阶逻辑
自动定理证明
SAT问题
CSP问题
描述逻辑
RDF/OWL
Cyc
答题规划
概念图
概念修正
过程规则
推理解释
前向链推理
反向链推理
逻辑归结
模糊推理
语义网
多AGENT系统
自组织特征映射
期望最大化
图模型
分布检验
MCMC采样
Gibbs采样
hopfield网络
放射基网络
规则学习
句法归纳
进化程序
强化学习
迁移学习
表示学习
集成学习
细胞自动机
人工生命
卡尔曼滤波
傅立叶变换
马尔科夫决策过程MDP
提升方法
排序学习
haskell

***************************************
模型论
可能世界模型
局部语义论
范畴论
instution
推理复杂性
图灵机
wang拼图问题
逻辑规约
情景论
模拟逻辑
时态逻辑
域态逻辑
空间逻辑
认知逻辑
缺省逻辑
四值逻辑
事件演算
非单调推理
认知机器人
circumscription
VC理论
不动点
分布式推理
PCA可学习性
随即过程
公理集合论
lambda演算
递归论
效用论
博弈论
哥德尔不完备定律
无免费午餐定律
渐进逼近定理
微分动力系统
势函数
选择公理
流形学习
低维嵌入
变分推断
*************************************
超递归可枚举计算
不可计算实数神经网络
量子计算
计算认知论
语义信息论
kolmogorov-chaitin复杂性
计算学习理论
社会机器
元认知
元逻辑
外记忆
心智扩展
心物问题
自私的meme
neo,红药丸还是蓝药丸?
---

《生理心理学》
心理是神经系统活动产生的现象。（一般认为）
意识：可表达的自我认知？思考并觉知我们自己的存在。
言语行为所涉及的脑部，也许正式负责意识的（裂脑手术）
一个裂脑病人企图用一只手打他妻子，而用另一只手保护她
感觉信息交叉表征的例外：嗅觉：左鼻子-》左脑

所有科学家的目标：解释他们所研究的对象。工科：应用
解释：概化：基于对许多相似现象的观察，来得出一般结论。（泛化）
       还原：现象背后更基本的过程描述现象
由于情绪会使心跳更剧烈，所以古人认为心脏是思维情绪之所在。
言语控制并不定位于脑的一个特定区域。
大脑皮层：神经传导：每秒27米
（实验：可验证性）
方法：实验性切除、电刺激法
群体：自然选择| 突变带来差异（适应进化方向的差异得以存活）
语言能力使知识得以传播。机器与人的差异：自编程性。
人脑的字编程性并不太强（计算劣势）
青少年成人的大脑：1400g。新生儿：350g 1000亿个神经元
要主动不要被动。大脑皮层：总面积2360平方厘米。厚度3mm
大约20%的大脑皮层在视觉分析中直接起作用。
你的想法和你的大脑并非是真正分离的。
不和谐音的识别发生在生命的早期
有皮毛皮肤：被抚摸的愉悦感
猫科动物无法探查甜味
对人类来说：嗅觉最神秘哦，有唤起记忆的特殊能力
嗅觉系统似乎专门用来辨别气味，而不是分析
在疼痛不可避免，且其伤害性不如目标重要的情况下。系统可以疼痛干扰行为
睡觉可能是人们可以体验的最强内驱力
慢波睡眠和快速眼动睡眠促进了不同类型的学习
快速眼动睡眠：脑部变化
海豚可以两个大脑半球轮流睡觉
在慢波睡眠时期脑的确是休眠的
晚上不睡觉会破坏人的认知能力
｛
快速眼动睡眠：非陈述性记忆：开车、投球、识别人脸
慢波睡眠：陈述性记忆：可以讲述的
｝
大脑的每个半球只对各自的睡眠负责
梦里只包含睡眠和运动吗？只触发视觉和运动系统
自然的推力是使胚胎自然而然的像雌性发育
人脑是一个性二形性器官
模仿参与对面部表情的识别
关系性学习
语言障碍大多发生在左半球
词汇涉及现实世界的客体动作或者关系
因此词义是由与它相关联的特定记忆所定义的。
手语早于口语
读写有共同的脑机制
成人大脑具有可塑性
身体和心里压力会释放皮质醇，其少量可以促进学习提高记忆力
皮质醇：晚上睡觉时逐渐升高，醒来时最高
慢性压力损害认知，
环境即是认知坐标系
---

天天说话，不见得就会说话。许多人说了一辈子话，没有说过几句好话。
人生不外言动除了动就只有言，所谓【人情世故一半都在说话里。】
唯口出好兴戎。
说话像行云流水，不能一个字一个字去推敲。（自然）
会说的教你眉飞色舞，不会说的教你昏头搭脑，即使是同一个意思同一句话。
左传  ： 外交辞令；战国策 ：纵横家言；世说新语： 清谈
红楼梦：漂亮话
韩非 ：说难  ； 《文训》：俞平伯 ；《立论》：鲁迅
至诚的君子人格的力量照亮一切阴暗。说话无需修饰
要说得巧，要说的少；言多必失，语多必败。
一眼可以兴邦，一言可以丧邦。
文章写了是可以修改的，说话不行。
说话有正经和随便两种。正式和非正式。
正经拉长了面孔。  【神而明之】
金人三缄其口。要张开了眼睛说话。（认清事理、认清环境）
风声雨声不吱声，度此一生。
国事家事不问事，平安无事。
对得意人勿讲失意话。
对门老妪不是人，西方王母转凡身，生养五子俱做贼，偷得蟠桃奉母亲。
这个婆娘不是人，九天仙女下凡尘，
谈话体：口才学：口语
美国：马丁·裘斯：
    冻结体：重大事件
    正式体：一般较重要场合
    商量体：日常目的
    随便体：朋友间
    亲昵体；亲人私下谈话
我国：朋友间正常口语，交际场合正式口语，隆重场合典雅口语。（仪式）
女人最要紧的是面部表情。【服装整洁，举止端庄】
-----------------------------------------------------
说话的态度：
    至诚足以感人。
    言必有信。
    察言观色。
    态度要温雅
    说话要委婉。
    最好让别人先说话
    同意别人的主张
    要有自己的立场
    多言无益
    用不同的方式来再三申述（而非简单的重复）
    学会运用拒绝语言
    要开发别人的话机【赞美、疑问、投其所好】
----------------------------------------------------------    
一滴蜜所能捉的苍蝇比一加仑毒汁所能捉的苍蝇还要多。
满招损，谦受益。
孔静幽默，humour：原意潮湿。
幽默在欢笑的背后隐藏着对事物的严肃态度。
讽刺在严肃的背后隐藏着开玩笑。
幽默的特点是尖锐而不刻薄，俏皮而不直露，蕴藏着说话者问候善良的气度和高超的语言艺术。
幽默是一种优美的、健康的品质。
荒谬对比、设置悬念、反转突变、认同认识。
倾听-使我们对任何人的一种至高恭维。
时间有不少事业，让那沉静的人占的胜利了。我们只见到肚子里留不住话的人遭受了惨败。
每一个人都有着他的自私心，他们所感兴趣的主要还是在于他们自己。
社会越是进步，人事也就越是繁复，这里的探求也越是迫切。
静坐常思己过，闲谈莫论人非。
语句要有力【谦美德也，过谦则怀诈】
    少道歉，
    诚恳
    真凭实据
    找出一个共同点来讨论
    正面辩难不如侧面进击
    有信心
----------------------------------------------------------
辩难的方法：
    正确的引出辩论者的话
    明确的指出对手的话的错处，不能模糊
    要说明对方谬误的危害及严重后果
        破坏性反驳
        建设性反驳
    反驳时可以反驳对方的论点、论据和论证方式。
    逻辑反驳；归纳反驳；直接反驳；间接反驳
------------------------------------------------------------
规劝：
    谁都不肯承认自己是坏人。
    闻过则喜 恐怕只是理想的人物而已
    忠言逆耳
  方法：
    先赞誉后劝导
    没有人爱听命令
    要给人家留个面子（留白）
    【己所不欲，勿施于人】
    自己来负担错误：是自己出错了吗？来让别人意思到错误
    用鼓励的方法
    用激将法（好胜心
    使人不自暴自弃｛人都会犯错，知错就改｝
    平等待人尊重对方
    心里相容对症下药｛迷信的人用迷信｝
---------------------------------------------------------------
培养勇气和自信：
    当众说话从容自如的本领。【练习，训练】
    要有破釜沉舟必胜的决心
    日子一长，自然习惯了
  害怕情绪：深呼吸几次，不要有小动作。
    成功来自练习
    第一次站在许多人面前讲话，突然很多眼睛望着你，脑子受了一种突然的刺激，现在需要的就是把脑子约束一下，使神经镇静下来。脑子可以统帅全身。控制自己。
--------------------------------------------------------------------
    磨练意志
演讲准备：
    威尔逊：把要说的题目写在纸上、再增加材料
    hitler：罗列事实形成结论。然后润色
    
几种形式：
    讲出事实，辩论事实，劝人去做
    指出错误，怎样补救，劝人去做
    补救情形，要怎样做，你帮忙的原因
    获得注意，获得信任，讲出事实，说出实行的动机
增强记忆力：记忆的自然法则：
    印象，复习，联想。
临场忘词：
    询问台下观众
    回忆说的最后一个字，和最后一句话
上得了台，下不了台就尴尬了
演讲也是虎头豹尾猪肚
--------------------------------------------------------------------
如何获取听众的注意力：
    用热情感染听众，现在是感情支配的世界
    动作诚恳【动人心者莫先乎情】
    要讲如鲠在喉不吐不快的话
    要讲有力的话
    灵活的变更音调的轻重快慢
    牢牢抓住听众的思维
    声音：咬字准确
--------------------------------------------------------------
姿势：
    动作就是雄辩没有学识的人们眼睛里的知识，实在远优于他们的耳朵。
    动作的意义在情感上的表现是十分有力的。
    注意环境中的空气、温度、和光线。
    让听众坐在一起。
    桌上无他物，台上无他人
    适合自己的姿势就是最好的。
    体态语
-----------------------------------------------------------
精巧的开头，和结尾。
编筐编篓难在收口。结句当如撞钟，清音有余。
演讲法则：
    尽可能收集资料和信息
    熟悉演讲场所位置和环境｛辅助设备｝
    了解之前和之后的节目安排
    动笔前三思
    想好讲稿结构
    以说话的语气写讲稿
    給初稿计时
    使用好简单的工具
    估计一下可能出现的问题
    在好友面前预先演讲一遍
    反复练习
    自我放松的有效方法
    适合的衣服
    时间充分
    开始前检查一遍
    事前不吃饭喝酒
    多带一份讲稿 
    面带微笑
    用眼睛和听众交流
    将演讲如生命一样去表现？

---

win10 配置完java环境变量后须重启电脑  17-10-24 下午一小时啊 大琳那

补码：7 -> -7  二进制逐位区反（包括符号位）。末尾加1


应该默认凡是以数字化形式存在的数据，都早晚会进入公共领域，即泄密
-------------------------------
代码大全                      
    17-8-16 上午              
    琼生
    大三 暑假 家中
-------------------------------
自顶向下、逐步细化、模块化
-------------------------------
一项新技术从诞生到被工业界广泛采用大约需要5-15年的时间。
新程序员们的某些实践经验来自于经验丰富的同
事．但主要还是靠自己──吃一堑，长一智──获得的，这往往是一个艰苦而缓慢的过程。
繁杂的日常工作往往使程序员们穷于应付而无暇阅读浩如烟海的书籍与资料
因为对于程序员来说，掌握多种语言是其必不可少的基本素质之一。而且，只有掌握了不受语法规则限制的编程准则，才能真正有效地提高你的编程效率和质量。
事实上，卓有成效的优秀程序员们所使用的技术并不神秘
最有效的编程技术是那些不受实现环境及语言限制的技术。
在小规模项目中，创建活动约占工作量的80％，在中型项目中也要占50％的工作量，而发生在创建活动中的错误则占总错误的50％到75％被忽视的创建活动事实上是唯一任何规模项目都必不可少的活动
创建活动有时被称作“实现”，它有时被叫作“编码和调试”，有时也称之为“编程”。
需求说明和设计文档可能会过时，但源代码却总是最新的。因此，源
代码必须具有最好的质量
---------2-----模型化---------------------------------
重大发现往往是从类比中产生的。
模型的力量在于它能提供生动形象的概念而易被人整个接受。并提供特性、联系和附加的疑问。
隐喻对加深软件理解所做出的贡献，与它对其它领域所做出的贡献一样大
70年代：数据处理正从以计算机为中心向以数据库为中心进行转变
软件科学是一门比其它学科年轻得多的学科，还很不成熟，远未形成一套标准的模型。
一个公式是一套完整建立的、进行某一些任务的规则。它的结果是可以预测的、确定的，并不取决于运气
软件隐喻更像是一束搜索灯光，而不是一张地图，它并不会告诉你到哪里去寻找答案
启发是一种帮助你寻求答案的技术。它的结果往往和运气有关
编程中许多错误往往都是概念性错误
开发软件最原始的隐喻出自“写代码”一词。这个写的隐喻说明开发一个程序就像随便写封信，你准备好纸、笔和墨水，坐下从头写到尾就算完成了。这不需要任何正式计划，你只是把你要说的都写出来。
几乎有50％的软件开发工作量是在软件最初发行之后才进行的。
如果你有25行代码设计错了。那你重新再来一遍好了，你不会因此浪费许多的。然而如果你是在造一幢房子，那修建的过程就要复杂些了，而拙劣设计的后果也严重得多
如果你想修建一幢陈设一流的别墅，情况就不同了，你可能定做全套家具，因为希望洗碗
机、冰箱等与你的家具协调一致，同时你还会定做别具风格的门和窗户。这种定制化的方式与一流软件开发也是非常类似的。为了这一目的，你可能创建精度更高、速度更快的科学公式。你也会设计自己的显示控制、数据库处理系统和自己的子程序，以使整个软件给人以一气呵成，天衣无缝的感觉
无论如何，无辜的人们没有义务为你的工作失误而付出代价。
把方法和技巧当作工具是很有益处的，因为这样可以使我们对其有一个正确的态度。不要把最新的“面向对象设计技术”当作上帝赐予的法宝，它不过是一件在某些场合下有用，而在某些场合下又无用的技术。
工具箱隐喻有助于我们保留一切方法、技巧、技术等，并在适当的
时候使用它们。
认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。
-------3--------------------------------------------
软件工程生存期循环：
    优秀程序员的一个突出特点是他们采用高质量的过程来创建软件。
    作为一个工程技术人员，教育你周围的人，让他们懂得技术项目的开发过程，也是你工作的一部分。
    过去十五年的研究证明，一次完成是最好的选择，不必要的修改是非常昂贵的。
    错误在软件食物链中存留的时间越长，它的危害也就传播得越远。
    过分地使用计算机（进行编辑、编译、链接、测试等）往往与低生产率紧密相联。而在计算机旁花费较少时间的程序员，往往更快地完成工作。这是由于频繁使用计算机的程序员在进行编码和测试之前，花在计划和设计上的时间较少。
    如果你发现方向不对，赶紧停下来检查你的方向。
    不应该允许一个以上的模块访问数据结构，除非是通过访问子程序，
问题定义->需求分析->
错误处理已成为当代计算机科学中最棘手的问题，
程序中有90％的代码是为了应付例外的错误处理或者内务处理而编写的
实现系统的语言对你来说是有重大意义的
当程序员使用自己所熟悉的语言时，其工作效率要比使用陌生的语言高得多。
程序员也可能同样受到他所懂得的程序语言限制。
一个运行良好的项目通常把20～30％的时间用于先决条件。这20～30％的时间中不包括进行详细设计的时间，因为它是创建活动的一部分。
程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
在开始编程前一定要确认需求定义工作一切正常。
在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
----------4--------------------------------
如果在给程序找一个好名字时感到困难，这往往意味着对程序的功能还不十分清楚。
如果其模块化
程度很高，就可以在需要时，用更好的算法或者汇编语言编写的子程序来代替速度较慢的程序而不致影响程序其它部分。
在每一行注释下面填上代码。
在心里对子程序进行查错处理
使用计算机来检查子程序错误
【跨平台的伪代码是否有必要？pdl】
【将跨平台的伪代码作为注释是否可行？】
应该在工作的每一步中都检查子程序，并鼓励同事们检查。这样，可以在投入的资金、和工作努力最少时便发现错误，从而极大降低改错成本。
----------5------------------------------
除了计算机本身之外，子程序可以说是计算机科学最重大的发明。子程序使得程序非常好读而且也非常容易理解
编写子程序的最大心理障碍是不情愿为了一个简单的目的而去编写一个简单的子程序。
只有 18％的弱内聚性子程序才是无错的
弱内聚性子程序的出错机会要比强内聚性出错机会高 6倍，而修正成本则要高 19 倍
子程序内：高内聚
子程序间：低耦合
IBM公司曾把子程序的长度控制在 50 行以下。
最近研究发现，当子程序长度是 100 到 150行时，错误率最低(Lind 和 Variavan1989)。
最易出错的子程序是那些大于 500 行的子程序
防错性编程是非常有用的。最有效的防错性编码
途径是一开始就不要引入错误。可以采用逐步设计方法、在编码前先写好PDL、进行低层次设计、审查等都可以防止错误引入。因此，应优先考虑它们，而不是防错性编程。不过，你可以把防错性编程与这些技术组合起来使用。
【使用断言】
【保留查找重要错误的代码】
程序中 39％的错误都是内部接口错误：
    确保实际参数与形式参数匹配
    按照输入一修改一输出的顺序排列参数
    如果几个子程序今使用了相似的参数，应按照不变的顺序排列这些参数
    使用所有的参数
    把状态和“错误”变量放在最后
    说明参数的接口假设。
    考虑建一个关于输入、修改和输出参数的命名约定
    仅传递子程序需要的那部分结构化变量
    不要对参数传递作出任何设想
    
建立子程序的最重要原因是加强可管理性（即降低复杂性），其它原因还有节省空间、
改进正确性、可靠性、可修改性等等。 强调强内聚性和松散耦合的首要原因是它们提供了较高层次的抽象性，你可以认为一个具备这种特性的子程序运行是独立的，这可以使你集中精力完成其它任务。下，放入子程序而带来巨大收益的操作可能是非常简单的。
子程序的名称表明了它的质量，如果名称不好但却是精确的，那么说明它的设计也是
非常令人遗憾的。如果一个子程序的名称既不好又不精确，那它根本就无法告诉你程序作了些什么。无论哪种情况，都说明程序需要改进。防错性编程可以使错误更容易被发现和修复，对最终软件的危害性显著减小
----6---------------------------
子程序是具有一定功能的，可以调用的函数或过程
模块则是指数据及作用于数据的子程序的集合。【c的头文件，其他语言的包】
maintenance：维护；维修
模块的内聚性准则 一个模块应该提供一组相互联系的服务
模块提供的功能必须是完整的，以便它的调用者们可以各取所需
在结构化设计中，黑盒子思
想便来源于信息隐蔽。在面向对象设计中，也是信息隐蔽引发了抽象化和封装化的设计思想。
对一个系统的改动可能涉及到几个子程序，但是，它只应涉及一个模块。
信息隐蔽：保密、封装。
容易改动是好的程序设计中一项最富于挑战性的工作。目的是将不稳定的区域孤立起来，以便使改动带来的影响仅限于一个模块中。
所有的复杂数据都很可能被改动；
隐含复杂的逻辑可以改善程序的可读性。复杂的逻辑并不总是程序的最主要方面，把它隐含起来可以使得子程序的活动更清楚。与复杂数据一样，复杂逻辑也是很可能变动的部分。
在程序语言层次上的操作
你的程序越是像一个实际问题的解决方案，它就越是不像程序语言结构的组合，那么，其质量也就越好，应该把过于专业化的信息隐含起来
模块并不是人们的目标，它只是数据及对数据所进行的操作的集合
常见模块域划分：
    用户接口、硬件驱动、输入输出、系统依赖
    数据管理、可重用代码、易变操作、互相联系的操作。
------------7----高层次设计-------------------------------
编码人员常常要进行一些设计工作。
“软件设计”：把一个计算机程序的定义转变成可以运行程序的设计方法。它是一个启发的过程而不是一个确定的过程，需要创造性和深刻的理解力。
自顶向下设计指导原则的依据是：人脑一次只能考虑有限数量的细节。如果你从一个较简略的子程序开始，逐步把它分解成更加详细的子程序，就不必每次考虑过多的细节。这种方法也常称之为“分而治之”战术。
设计是一个复杂的过程。因为你很难把正确答案与错误答案区分开来。
你在学校中设计的程序和在实际工作中设计的程序最重要的不同是：在学校中遇到的程序设计问题，几乎没有哪个是险恶的
设计中，总是吃一堑，长一智的。
一种很有效的启发工具就是硬算。不要低估它。
最重要的设计原则之一是不要死抱着一种方法不放。
怎样解决问题：
    理解问题，你必须理解要解决的问题
    设计一个方案。找到已知数据和未知之间的联系。
    执行你的计划。
    回顾，检查一下答案
高质量设计的共同点：可靠性。
设计是一个启发的过程。 固执地坚持某一种方法只会抑制创造力，从而产生低质量的
程序。坚持设计方法上有一些不屈不挠的精神是有益的，因为这可以迫使你对这种方法进行充分理解。但是，一定要确信你是在不屈不挠而不是顽固不化。
面向对象设计更适于子程序与数据的组合
结构化设计比较适合于小规模的子程序组合
----------8---------------------------------------
一张良好的数据结构清单是程序员工具箱中的一件重要工具。
数据初始化很容易产生错误,规避方法：
    检查输入参数的有效性。
    在使用变量的位置附近对其进行初始化
    要特别注意计数器和累加器
    查找需要重新进行初始化的地方
    对命名常量只初始化一次，用可执行代码初始化变量。
    按照所说明的对每个变量进行初始化。
    利用编译程序的警告信息。
    设置编译程序使其自动初始化所有变量
    使用内存存取检查程序来查找无效的指针
    在程序开始初始化工作内存。
---------9-----命名-----10--11-12-13-14-15-16------
名称的最佳长度应介于 MaximumNumberOfPointsSincel896 和 x 之间
多从读程序者而不是写程序者的角度去考虑变量名称
作用域指的是变量名称的影响范围，也可称之为可见性，即在程序中某一变量被知道和提及的范围。
“持久性”指的是某一数据的使用寿命
研究发现全局变量的使用与错误率上升之间并无联系。
模块化！模块化！模块化！”。
建立使你一眼即可识别出全局变量的命名约定。
尽量减小变量的作用域。把对变量引用集中到一起，应尽量使变量成为局部或模块的，
避免使用全局变量。
使每个变量有且仅有一个功能。
如果全局数据确实不可避免的话，应通过存取子程序来对其进行存取操作。
避免" " 奇异数 "(magi c numbers)
概念上，每个指针包括两部分:内存存储单元及对这个存储单元中内容的解释。
表驱动方法：
    vector
    hash
    阶梯
可以用表来代替复杂的逻辑结构
抽象数据类型是降低复杂性的有力武器。它使你可以分层编写程序，而且是从问题域而不是程序语言细节来编写顶层的程序。
由程序的数据中心论转移到控制中心论
一个循环该有多长：
    使循环尽可能短，能一目了然
    限制嵌套超过 3  层
    使长循环显得很清楚
编写循环的简单方法——从里到外
许多情形下，循环就是为了处理数组而编
Ada语言支持goto，它是历史上用得最仔细的工程程序语言。Ada 语言是在 goto 的争论后进行开发的，但经过仔细分析，Ada 决定保留 goto。
goto 方法避免嵌套太深和不必要的条件测试
消除 goto是很难的，但它却是很好的脑力活动
在问题较简单时，递归调用能把问题很巧妙解决。要慎用递归调用
------17---
用决策表代替复杂的条件
编写肯定形式的布尔型表达式
C语言中0有几个用途:它是一个数字量；在字符串中它是一个结束符’\0’，它是地址指针所允许的最小值；在逻辑表达式中它表示假
C中 whi l e语句后必须跟一条语句，但也可以是空语句。
过深的嵌套已经困扰计算机界达15年之久了，但现在依然是使代码出乱子的罪魁祸首之一。
很少有人理解嵌套超过三层的 i f 语句
结构化编程是什么意思？
    程序总是单入单出的结构，即程序只能从一个地方开始且也只能从一个地方退出的代码块，没有其它的进口与出口。
由于这两个程序的复杂性较低，因此这两个程序的出错数比 Hewl et t －Packard的其它程序都低。
下面两种方法可以帮助降低程序复杂性：
    首先，你可以做一些动脑筋练习来提高在脑中打底稿的能力。但大多数程序都很大，而人同时考虑的问题一般都不能超过5～9个，因此靠提高脑子的容量来帮助降低复杂性能力有限
    第二，要降低程序的复杂性就要求你彻底理解你所要解决的问题。
复杂性太高，就拆分为子函数
（数 分支、循环、and、or的数量。每一个算1，超过5即拆分。）
降低复杂性是编写高质量的代码的关键
---------18---------------------
格式化的基本原理是用直观的布局显示程序的逻辑结构
把程序语句有规则安排时，专业编程员对程序的记忆比新手好。但当随意安排各语句时专业程序员的优势下降了
要尽量多地用括号。
常规是限制一条语句不超过 80个字符
【使续行的结尾易于发现】
【每行仅写一条语句】
【头脑不太清醒的时候，一步都不要跳】
即使你读有副作用语句时非常轻松，不要指望别人也跟你一样
注意数据类型定义的对齐
每行只定义一个数据
一个好的注释能极大提高程序的可读性。若注释不成功，则会帮倒忙
把注释行至少用一个空行隔开
把一个模块放在一个文件里。
一个文件中的所有子程序构成一个模块。一个模块才是程序中体现你设计的那一部分
把一个文件内的子程序区分清楚。要把一个子程序与别的子程序区分开来至少要用两个空行。
布局首先考虑的是去显示程序的逻辑结构。
结构化代码是有其自身目的的，你最好还是用一些约定俗成的布局形式而少来创新，以保持与别人协调一致
有关部局的好多观点纯属一个信仰或者说个人喜欢问题，努力把客观需要和主观喜好分开。遵从一些明显地规划，以选择你所喜欢的布局形式。
------19--文档------------
假如程序标准合理的话，大多数编程人都喜欢写文档。就像布局那样，好的文档是编程人员投身编程中自豪的标志
【实际上，大约一项大工程全部力量的三分之二放在了创建文档上，而不是源代码上】
注释有帮助但更有破坏性
注释在高于代码的抽象水平上解释代码要做什么事。
错误或语言环境独特点都要加注释
保持注释接近于它们描述的代码
注释应表达出代码本身表达不了的意思
好的注释是在意愿层次上进行的，它们解释的是“为什么”而不是“是什么”
源代码中应含有关于程序的绝大部分重要信息
是否注释就像是立法。注释得好，是非常值得的，注释得不好，则是浪费时间而且有害
--------20-------工具-------------------
2O％工具起到了 80％工具的用途
最先进的编程工具能提高产量达 50％以上，编程工具也能减少在编程时所需做的许多乏味的细节工作
· 好的工具使编程更容易。
· 你可以编写大多数你需要的工具。
· 用今天的技术水平能编出高水平的编程工具。
【如果你习惯于开发小项目，你的第一个中等项目将是非常困难的，而且不是你预期中的令人愉快的成功】
如果只有你一人开发项目，对项目成功或失败影响最大的正是你自己
·一些小项目中的活动并不能想当然地用于大项目中，你应仔细计划它们。随着项目增大，创建作用减弱。
·随着项目的增大，交流方法应简化。各种方法的使用应因时而异。
· 在相同条件下，大项目的生产率比小项目低一些。
· 在相同条件下，大项目的每行错误数比小项目的每行错误数多。
软件计划是变化：代码在变化、设计在变化、需求在变化
程序员和管理者都是普通的人，当他们受到礼待时往往干得更好
调试通常要占一个传统的初始软件开发周期的 50％
花费中等时间的程序员所编的程序错误要少得多
并不是所有质量保证目标都能实现。确定你想实现的目标，并将其让你所在组的每一个人知道
解释一下问题，足以使你找到问题症结之所在
单一的软件测试方
法只能取得有限的效果——单元测试的检错比仅为25%，功能测试为 35%，而集成测试为 45%，相比之下，设计和代码检查的检错比平均为 55%、60%。
检查是一种特殊类型的评审，它在错误检查中被证明是行之有效的，并且和测试相比，它是一种相对较为经济的办法
检查也可提高生产率达 20%左右
代码阅读平均每小时可发现 3. 3 个错误。
调试平均每小时可发现 1. 8 个错误 代码阅读在软件生存期中要比其它调试方式多发现 20%到 60%的错误。
评审在发现错误方面较测试要好
评审侧重于错误发现而不是纠错。
普查和代码阅读是检查的候补方法。代码阅读可有效地利用每个人的时间
-------------25--------------------
【测试是发现错误的方法，而调试是对错误进行诊断并改正它们】
单个测试方法(单元测试、功能测试、部分测试、系统测试)，通常只能发现少于50％的错误数。几种测试方法的集成使用，只会发现少于 60％的错误
单元测试所占总的项目时间从 8％到 35％不等
你对错误的猜测是建筑在直觉或过去的经验上。
    80%的错误往往出现在 20%的子程序中
    50%的错误往往出现在 10%的子程序中
书写错误是一个相当普遍的错误源
大多数实现错误来自程序员 。在所有错误中，有 95%的错误是由程序员本人引起的，2%的错误由系统软件所引起，l%是由硬件引起
大多数错误是容易改正的
软件质量的基本原则：开发一高质量软件要比开发一低质量软件并改正其错误要省事。
你会感到你浪费数小时的时间来寻找测试数据而不是代码中的错误是一件多么愚蠢的事啊！
管理回归测试的唯一可行方法是使回归测试自动化
通过采用基本测试、数据流分析和错误猜测你可生成许多测试用例
错误倾向于集中在少数几个子程序中。找到这几个子程序，重新设计和重写它们

-----------26----------调试----------

调试用于发现错误的根源并改正它，而测试恰好相反，它是用来发现错误的。对有些项目，
调试可占到整个开发时间的 50％。对许多程序员来说，调试是编程最为困难的部分。
同测试一样，调试并不是提高软件质量的一种方法。它只用于改正错误
提高软件质量的最佳方法是遵循详细需求分析、有一个出色的设计、高质量编码方法。调试为最终的一个不得已之举
如果你是靠尝试来编程，产生错误是必然的
将程序中插入输出语句以检查错误
如果你并不清楚程序在干些什么，编程是令人痛苦的
存一些可乐饮料之类的东西，因为你在到达终点之前将是漫漫长夜
假设错误是自己的，可使你免受宣称某个错误是别人，而最后发现是你的而不得不改口的窘迫处境
调试包括发现和改正错误。发现错误（并理解错误）将化费 90％的调试时间
生成更多的数据以产生更多的假设
检查一般错误。使用代码质量检查表以激发你能考虑各种可能错误
发现错误的诀窍：
    使用所有可能数据进行假设
    求精产生错误的测试用例
    通过不同的方式再生错误
    生成更多的数据以产生更多的假设
    使用否定测试的结果
    提出尽可能多的假设
    缩小可疑代码区域
    怀疑已发生过错误的子程序
    检查最近修改过的子程序
    扩展可疑代码区域
    逐步集成
    耐心检查
    为迅速调试设立最大时间
    检查一般错误
    跟其它人谈论有关问题
    暂时终止对问题的考虑
语法错误：
    不要相信编译程序信息所给行数
    不要相信编译信息
    不必相信编译程序的二次信息
    分解
    寻找另外的注释和引号
越是容易就越容易出错
改错：
    在改正问题前真正了解其实质
    理解整个程序，而不只是了解某个问题
    确诊错误
    放松自己
    保存初始源代码
    修改错误问题，而不是症状
    仅为某种原因修改代码
    每次作一个修改
    检查你的修改
    寻找相似错误
调试心理：
    首先，它强调良好编程习惯的重要性。好的格式、注释、变量名。子程序名以及其它编程风格，有助于建立编程背景，这样所出现错误才能有所差别。心理因素的第二个影响在于当错误出现时对部分程序的挑选上
    一般说来，实践知识可使优秀程序员缩小其研究领域并能迅速地发现错误。
    当你在一十字路口走错了方向时，你必须转过身来再向前走
    建立假说、收集数据、分析假说、有条理地剔除无用的数据——但许多人对这种正规过程不习惯
    人们总是看到他们期望看到的东西
    比较程序能指出错误并提醒你的记忆
最简单和最有效的调试工具是你本人的编译程序
    将警告信息视为严重错误信息
    使你的编译程序警告级为最高，修改你的代码以便不产生任何警告错误
    为整个项目的编译设立标准
    
高级符号调试程序要比输出语句有效得多
一个好的调试程序允许对数据进行充分的检查，包括结构化数据和动态分配数据。
不采用调试程序，而应用人工执行程序的方法发现错误。 
有些早期的研究指出人工调试并不是进行有效调试所必须的
任何有力的工具被正常使用，也可能会被误用
你仍需花费时间提高你的调试技能——因为最好和最差的调试效率差别为 10:1，甚至更大。
发现和改正某错误的关键是，有一个有条理的方法，注重你的测试，这样每次你都能
向前迈进一步。
·在你改正一个问题之前应理解问题的本质，对错误源的任意猜测和修改只会使你的程
序更为糟糕。
·调试是软件开发的有力工具。你应能利用调试工具。记住你还应好好动脑筋。
 ------27--------集成------------------------------------
 程序既可以通过分段的方法，也可以通过递增的方法来集成
 递增集成法有许多形式，除非工程非常琐碎，这些形式中的任一种都比分段集成好
 -------28---代码调整-------------------------
 程序设计、数据结构选择和算法选择通常能产生更好的改进效果
 有效的代码不一定是好的代码
 减少高级语言中语句（代码）的行数可提高机器码的执行速度或减小机器码所占空间——错误！
 一种操作也许比另一种操作更快或更省空间——错误！
    没有也许，只有事实。
    你应该处处优化程序——错误
    测量需要精确
没有必要时，就不要进行优化。
性能是软件整体质量的一方面，可能并非最具影响力的一方面。调整代码只是程序性能的一部分，恐怕亦非最重要的。程序结构、具体设计数据结构和算法选择，对于程序规模和执行速度的影响要比产生代码本身的工作大。
优化设计关键要用到定量测量。重要的是找到确实能改善程序性能的段落，在此就要
强调优化的作用。
·大多程序主要的时间花在小部分代码上。在执行程序及测试前不容易知道是哪部分代
码。
· 为写出优良程序最好是写出清晰易读和易修改的源程序来。
-----29--代码调试---------------------------------
循环段要被执行多次，程序的弱点多半在循环段内
查表法代替复杂判断
尽量用整型数不用浮点数
尽量减少数组维数
盲目听从任何一种代码调整建议都是危险的，在你没有在自己特定的环境下尝试过建议前，你不能做出任何肯定
｛不同语言不同编译器差别巨大，很难有统一的标准｝
【现代计算机对于调用子程序没有任何惩罚】
使用较多的直接代码要比用调用子程序的耗时大些。
优化的结果因不同语言、编译器和环境而大不相同。如果不对特定的优化进行测试，
没人知道结果会怎样。
· 头一次优化未必是最好的。即使你找到了一个好的，试着寻找更完美的。
· 代码调试有点像原子能，是一个有争议的题目。有些人认为它对可靠性和可维护性是有害的，根本不该使用。有些人认为只要注意，它是有益的。如果你决定要使用本章描述的技术，千万小心从事
设计跟着需求走
优化既是危险的又是趋向完善的机会
｛当自己都不知道自己在写什么的时候，就不要写了
    时刻保持清醒，让程序在自己的控制之下。
｝
如果你想成为一个高手，你得全靠你自己下功夫
你无法改变自己的聪明程度，但是你可在一定程度上改变自己的性格。已发现，在程序员成为高级程序员的过程中，性格是更有决定意义的因素
你的个人性格直接影响你编写计算机程序的能力：
    聪明和谦虚、好奇心、诚实、合作与交流、创造力和纪律、懒惰、坚持、经验、习惯

一个杰出的程序员需要遵守许多规则
阅读手册、阅读有关书籍和期刊、学习成功项目的开发经验、在你行动之前进行分析和计划、阅读解决问题的有关方法、实验、在开发过程中建立自我意识。
【她的代码给了她大量的机会显示她的改错能力】
手册恐惧症在程序员中很流行
对编程的痴迷纯粹是胡闹，并且几乎注定要失败。
高级程序员的发展和生成与天才并无多大联系，任何事情都和个人的发展有关
令人吃惊的是，小聪明、经验、坚持和欲望既可帮助你也能妨碍你
许多程序员不主动去吸收新信息和新技术，而是靠偶然地上获得一些新信息，如果你
抽出少量时间学习别人的编程经验，过一段时间后，你将在你的同行中脱颖而出。
好的性格对养成良好习惯有很大影响。为了成为一位高水平的程序员，你应养成良好的习惯，其余的就会随之而来。
【计算机科学的核心是减少复杂性】
问题的复杂性可以通过将系统分成子系统而得到降低
使用相同的标记符对模块数据是无害的，因为它不会使你的注意力分开。
复杂性应可通过好的设计得到最大程度的降低
编码约定在某种程度上同样可降低复杂性抽象是另一种通过在不同的层次上处理不同的细节来降低复杂性的
【抽象：综合体的重命名？】
对程序员来说，降低复杂性是一个很关键的问题
人们在一起工作的方式，决定了其所在集体力量的大小
【不成熟的乐观是对时间的浪费】
软件开发是一种创造性的活动
私人程序可随意编写并且可充满各种限制
将问题分解成不同的抽象级
程序编制既不是完全的一门艺术也不是一门科学
如果你自己都难以理解，别的程序员就不用提了
重复方法对代码调整同样有益。一旦软件是可运行的，你可重写小部分代码以提高整个系统的性能。
重复方法对代码调整同样有益。一旦软件是可运行的，你可重写小部分代码以提高整个系统的性能。
偏执在软件开发过程中有着各种变种：顽固地地坚持某种设计方法，执着于某种特定格式或注释风格，一味地不用 goto 语句，它都是不正确的
对某种方法的盲目迷信，会阻碍你对编程问题最有效解答
重要的是你应对软件开发的各方面都保持开放的思想
面向问题而不是解答的编程有助于对复杂性的管理。
· 注意警告信息是相当重要的，因为编程几乎是纯智力活动
-----------------------------------------------


--------------编程矶珠--------------------


---------------------------------------
仔细分析小问题有时可以带来巨大的实际好处。
【问题定义、算法设计、数据结构选择】
1、恰当的问题。2、数据结构。3、多通道算法【每读一次就像完成前进一步】
4、时间和空间的权衡。5、简单的设计【设计师的至高境界不是他不能在往作品中添加神魔东西，而是他不能再从中取走神魔东西】【解决复杂性问题时】
你可能正在解决一个错误的问题，所以不能取得进步。打破概念上的障碍，转而解决一个更简单的问题。
排序的目的就是加快查找速度 【和树，hash一样】
判断力只会伴随解决问题以及反省问题解决方案那样实际的体验而出现。
能用小程序的话就不要编写大程序【减少思维量】
表示法是编程的精华
第一个二分查找程序于1946年就已经公布了，但是第一个没有bug的二分查找程序在1962年才实现。
程序开发要在验证观念指导下进行；
证明程序正确性：测试用例
保持代码的简单性通常是正确性的关键。
使用脚手架调试一个算法
printf语句通常实现要更快一些，比复杂的调试工具也要更加高效一些。
断言：验证程序得正确性。
调试：找到魔术表演的原理。
------第二部分 性能-----------------
加速是需要代价的，｛增加代码量，重新设计的时间、｝
为整个系统提出一个骨架后，设计者应该做一个封底估计
性能分析在系统设计期间很关键
正确第一，效率第二
两个答案比一个答案好，河水的流入量等于流出量
会计72法则：时间y年，年利率r%，r*y=72，你的钱会翻番。
π秒是一纳世纪，3.155*10^7 s==一年
纠错次序【语法，逻辑，算法与结构、系统调用、硬件】
优秀的工程师意识到自己知识的局限性。并设法弥补
任何事情都应该做到尽可能的简单，除非没有更简单的了。
费米近似：用纸片的飞行距离计算爆炸当量
通过适当的引导，这类估算问题可以鼓励孩子保持长达一生的好奇。
复杂算法有时可以极大的提高性能。
在效率和可维护性上找平衡
代码优化最重要的原则：尽量少用代码优化
不成熟的优化是灾难的根源
------第3部分 产品---------------
程序员的任务1、解决已经存在的问题2、解决将要出现的问题
在深入研究和理解之后，能够改进任何解决方法。
并且在任何一种情况下，都能够进一步理解解决方法。
---------------
用空间换取时间规则
用时间换取空间规则
循环规则：循环合并、代码移出循环
逻辑规则：代数恒等式替代逻辑表达式
	设置上界
过程规则：消除尾递归、协同例程
表示规则：编译时初始化、
*******************************************************


        practice of programming
        《程序设计实践》
        2017-8-30
        学校宿舍
    ---------------------------------------------------
 1、
    全局变量用长名字，局部变量用短名字
    全局性的函数、类、结构都应该有注释。小函数单行注释 （函数前）注释长度不要超过代码长度
    越大的程序越需要系统化的命名
    函数名 采用动宾结构 gettime（）setvalue（）
    【采用一致的缩进、加括号风格】
    使用空格和括号使表达式更清晰
    分解复杂表达式
    【一步只做一件事】
    无穷循环：for(;;); while(1);
    strlen()未计入\0
    任何牵涉到存储分配的函数，它们的返回值都必须做检查
    减少嵌套（循环、条件）
    宏使用 函数、常量替换
    注释应该提供那些不能一下子从代码中看到的东西
    否定性的东西不好理解
4、 留出两倍的时间，第一次做出来的是准备丢弃的。
-------------------------------------------------------
编程范型提供了（同时决定了）程序员对程序执行的看法。
例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，
		而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。
由于理解（understanding）自然语言，需要关于外在世界的广泛知识以及运用操作这些知识的能力，
自然语言认知，同时也被视为一个人工智能完备（AI-complete）的问题。
同时，在自然语言处理中，"理解"的定义也变成一个主要的问题。

第一，传统的基于句法-语义规则的理性主义方法受到质疑，随着语料库建设和语料库语言学的崛起，大规模真实文本的处理成为自然语言处理的主要战略目标。

第二，统计数学方法越来越受到重视，自然语言处理中越来越多地使用机器自动学习的方法来获取语言知识。

第三，浅层处理与深层处理并重，统计与规则方法并重，形成混合式的系统。

第四，自然语言处理中越来越重视词汇的作用，出现了强烈的“词汇主义”的倾向。词汇知识库的建造成为了普遍关注的问题。

自然语言理解是研究如何让电脑读懂人类语言的一门技术，是自然语言处理技术中最困难的一项

    What?：何谓理解？
    How?：电脑如何能理解人类语言。
    When?：电脑了解到何种程度才算理解。
    Where?：自然语言如何转换成电脑可理解的结构，如何储存。
    Why?：电脑真的能理解吗？为何能、为何不能。
机器学习是人工智能的一个分支。人工智能的研究是从以“推理”为重点到以“知识”为重点，再到以“学习”为重点
-------------------------------------------------------------
Galton: Regression towards mediocrity，直译为回归平庸。
Galton发现如果父母特别高，子女多较父母矮而较普通人高，是为回归平庸。统计上的原理可以用正相关二维【正态分布】的条件期望来解释。
------------------------------------------------------------
effective debugging
	希腊
宏观：
	利用事物追踪系统，（保证开发的条理性）（记录下自己的决定）
	在线 准确查找问题
	检查前置条件、后置条件
	自上而下分析程序出错位置，自下而上由问题查找bug
	两个相似版本进行对比（其中一个可运行）【综合考虑所有影响因素】
	使用软件自身的调试，（日志，性能表，测试用例）
	使用多工具构建，多环境运行
	把工作焦点放在最重要的位置上，
	
通用方法做法：
	A380有400个物理部件，linux内核900万行（软件很复杂）要相信自己能够把问题解决
			【投入精力学习环境，工具和知识】
	重现问题（在副本环境中）
	修改完代码后要尽快看到结果（避免错误累积）
	复杂场景下：测试自动化
	使用专门的监测和测试工具
	是故障更加突出
	清理冗余信息或者调试的垃圾
	
通用的工具和技术
	unix命令行工具
	vim vs 等IDE
	使用git
调试器的使用技巧
  gdb等（最好是图形界面、查看信息更多）
    单步调试、反向调试、查看变量值、把调试器连接到正在运行的进程上
    运用核心转储信息进行调试、
    学会查看汇编代码及原始内存
编程技术：
	对可疑代码进行评审，并手工演练这些代码
	和同事、小黄鸭、角色扮演来讨论代码
	使软件进入调试状态（游戏界面现实动态运行时参数）   
	使用相关语言和平台的日志框架
	对软件进行单元测试
	设置断言
	【改动受测程序以验证自己的推想】
	尽量缩小正确代码和错误代码（副本）之间的差距
	简化可疑代码（重写，规范化，换种语言重写）
	改善可读代码的可读性与结构（说到底就是更清晰）
	要清楚bug的根源，而不只是消除其症状
编译时的调试技术；
	对中间代码进行检查 C：查看预处理后的 -E 反汇编 ；java指令
	使用静态程序分析工具 -wall
	配置项目采用固定的配置和构建方式
	使用更加严格的编译和调试设置
运行时调试技术：
	测试用例
	让软件在遇到问题时尽早退出
『	查看运行日志』
	对相关操作进行性能评测
	追踪程序的执行情况
	使用动态程序分析工具：Valgrind
调试多线程代码：
	优先使用高级并发组件。
	糟糕的是循环等待
	专门的工具
	把不确定的东西隔离出来或将其移除
------------------------------------------------------------------------------

#五百年必有王者兴

18-2：
	python核心设计哲学是代码可读性和语法，能够让程序员用很少的代码来表达自己的想法。
	for *正常情况**else：异常情况
	内存应用可视化：
		objgraph，xdot
	列表推倒[] 和生成器表达式（）:
		列表推倒返回的是一个列表，
		生成器表达式返回的是一个迭代器
		多个for循环为嵌套关系
	int(one,two): one 字符串
				  two 默认为10进制
18-1-13:
	The @ (at) operator is intended to be used for matrix multiplication. 
	No builtin Python types implement this operator
17-12-8：
	a,b=c,d
	赋值操作同时进行，先获取右侧所有元素的值，在统一赋给左边

	在Python中，所有以“__”双下划线包起来的方法，都统称为“Magic Method”

17-12-4：
	一个K_means写了五个小时，刚写完算法逻辑
	【心态有点崩】
	结论：永远不要预估你所不知道的事情。
17-12-3：
	ipython 保存使用过的命令
		logstart logoff
	ABCs：抽象基类

17-11-25
	二进制：B binary
	八进制：O octal
	十进制：D decimal
	十六进制 H hexadecimal

17-11-1
	奥卡姆剃刀：在所有可用的候选项里，用最简单的那一个。
17-10-16
    对于用户来说，使用这些库，要比自己去从头开始容易得多。我们要开始攀登巨人的肩膀了。
    Python的强大很大一部分原因在于，它提供有很多已经写好的，可以现成用的对象


17-9-10：创建虚拟环境 venv
	1、python -m venv .   #在当前目录创建虚拟环境
	2、/Scripts/activate.bat #执行激活程序（win7下
		source /bin/activate  #linux下
		会显示虚拟环境的名称
	3、以后使用虚拟环境的时候激活就行了。
17-5-1：
	eval（str） 字符串转化为表达式。返回表达式结果
	enumerate(list,start=3) 从start开始给list编号
	dir（） 展示存在的对象及namespace
	type(object) 返回object的类型
	exec('print("asd is me.")')  ==> asd is me. 执行pthon语句串、字节码、对象均可。
	ord（unicode char） 将unicode char 转换为对应的十进制数
	hex（integer） 将一整型数转换为16进制字符串
	id(object) 返回对象的id（内存地址 cpython）
	bin(integer) 将一整型数转换为2进制字符串
	len(str) 返回str的字符数
	divmod(30,7) ==>(7,2) 求除数和余数
	bool isinstance（object，type）对象是否是该类型的实例
	bool issubclass()  是否是子类
	iter（） 返回迭代器对象
	memoryview(byte-like object) 返回对象的内存地址
常见：
	float(str) 将串转化为浮点数。
	help(object) 显示对象的帮助信息。
	next（iter）返回迭代器对象
	oct(integer) 整型数转化为八进制的字符串。
	open（）打开文件
import os
	os.getcwd() 获取当前路径
	os.getenv('path') 获得制定环境变量的内容。
	os.getlogin() 获得登陆名
	os.getpid() 当前进程id
	os.getppid() 父进程的id
	os.putenv(key, value)  设置环境变量
**************************************************
python 类型转换：
int(x [,base ])         将x转换为一个整数
long(x [,base ])        将x转换为一个长整数
float(x )               将x转换到一个浮点数
complex(real [,imag ])  创建一个复数
str(x )                 将对象 x 转换为字符串
repr(x )                将对象 x 转换为表达式字符串
eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s )               将序列 s 转换为一个元组
list(s )                将序列 s 转换为一个列表
chr(x )                 将一个整数转换为一个字符
unichr(x )              将一个整数转换为Unicode字符
ord(x )                 将一个字符转换为它的整数值
hex(x )                 将一个整数转换为一个十六进制字符串
oct(x )                 将一个整数转换为一个八进制字符串
chr(65)='A'
ord('A')=65
int('2')=2;
str(2)='2'
//*************python调用C
import ctypes
dll=ctypes.cdll.LoadLibrary
lib=dll("./cpp_dll.so") #in windows use dll
print "python call cpp dll:"
lib.add_func(2,3)
********************************************
yield 的用法？

查看帮助：help(object)  包括相关函数返回值
列出内容：dir(object)  只列出属性方法名


/****************************************
    收录了与python相关的技术探讨。
    2017-9-22晚上。
*****************************************/
import语句：
	模块 是您为了使用而进行导入的一项资源。
	这个过程就好比是从文件柜中取出一张纸，并将其放在桌面上，
	以便进行使用
	
上下文管理器：context_manager
	上下文管理协议的对象
	有__enter__()和 __exit__()方法
	with会调用上面两个方法
	from contextlib import contextmanager
	@contextmanager 在方法前（方法只能产生一个值）
	
	
dir()的用法：
	dir()  :当前作用域中的名称
	dir(__builtins__) :已经绑定的内容
	

python中的key函数和比较函数的区别
	key函数：key=lambda x:x[0]  key是要排序内容的一个迭代器（只接受一个参数）
	compare函数：使用的是-1，0，1 三个之值来判断大小

python -m py_compile lian_xi.py 
	编译.pyc文件的方法
	编译完成的文件放在 __pycache__/ 目录下同名的文件

图形化界面：
	pyfltk：与pyqt tkinter功能相同
	但更轻量

.pyc  是python的字节码 在内存中执行完成后
		重新写回的硬盘文件
python 的多维数组：
	a=[[]]*3  #[[],[],[]]
python中类方法参数中没有self参数
	为静态方法。由类名调用，使用类变量

python中的函数对象：
	#定义
	class obj：
		def __init__(self,a):
			self.a=a
		def __call__(self):
			return self.a
	#使用:  像函数一样使用类
	val=obj(a)
	
python的内存管理：
	大对象：：指针，
	小对象：：拷贝（更改其值，执行拷贝操作）
	【可变对象，不变对象】
global val
	声明全局变量（在局部作用域）
	可用于闭包

Python的专家们精心制作了一个标准答案：”不要使用多线程，请使用多进程。
    基于线程的编程毫无疑问是困难的
    对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行
    超过十年以上，没有比解释器全局锁（GIL）让Python新手和专家更有挫折感或者更有好奇心。
	
这种内部函数的局部作用域中可以访问外部函数局部作用域中变量的行为，我们称为： 闭包

PythonWin

函数式的优点：
	形式上可证明
	模块化
	可组合性
	易于调试和测试

生成器可以throw（异常类型，‘串提示信息’）
	generator.close()  #使用后关闭
	
Fredrik Lundh曾经建议使用以下一组规则来重构lambda的用法：

    编写一个lambda函数。
    写一个注释解释lambda做了什么。
    花一段时间研究注释，并想一个能够捕捉到注释精髓的名字。
    使用该名称将lambda转换为def语句。
    删除注释。


************python 函数式编程 FP***************************************
函数名也是变量，高阶函数：参数有函数对象
高阶函数
		map    并行计算 映射	map(函数，数据)
		reduce 串行计算 迭代  reduce（函数，数据）
		filter() 过滤器  串行计算 filter（函数，序列）
		sorted 排序
返回函数不要引用任何循环变量，或者后续会发生变化的变量
匿名函数 lamda ：
装饰器 decorator @被包含函数(装饰器)？
偏函数：int2（变量） = functools.partial(int（原函数）, base=2)  默认形参

同输入同输出：函数退出前变量重置？
**************模块
与java相同， 同级目录下必须有 __init__.py 文件
任何模块代码的第一个字符串都被视为模块的文档注释；
__xxx__ 特殊变量; __xxx 私有变量（函数）==_classname__xxx
添加路径：
		import sys
>>> sys.path.append('/Users/michael/my_py_scripts')
*************************oop
__init__(self,xx):   //类初始化函数
object类：所有类的基类	class name(babaclass):	对象=classname（）
封装：数据集合与隐藏 继承：类关系（具体化） 多态：函数重载，重写
动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。
__slots__=('name','age','属性')  //限制属性
@property  ？？
python可以多重继承，__str__(self) 实例信息 定制类？？
enum 枚举类？？
动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
mateclass ？？？
*************************wrong&&test&&debug
try ... except ... finally ....    。raise 抛出异常
基类：BaseException  常用异常：https://docs.python.org/3/library/exceptions.html#exception-hierarchy
调试：
		第一种方法简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看
		凡是用print()来辅助查看的地方，都可以用断言（assert）来替代：assert 判断，‘打印信息’
		把print()替换为logging是第3种方式，输出到文件
		第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态
test：
		unittest模块
		单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。
		单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。
		单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。
		单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。
文档测试：
		doctest 模块
**************************io
同步io：cpu等着，异步io：cpu不等。	f=open('filename','r',encoding='gbk',errors='ignore') f.read() f.close()	read(size)	 readline(size) none==all
使用with语句操作文件IO是个好习惯。???  stringio bytesio
我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。
把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling Python提供了 pickle模块 来实现序列化。 json 模块
**************************进程&&线程

---

TOMCAT 服务器学习
@1:配置文件学习：
	/web-inf 该目录及其子目录下的文件都是不可访问的
		web.xml部署描述
		/classes 存放所有的.class文件
		/lib 存放类文件打包后的jar文件
	mate-inf：项目描述文件目录。
	conf/tomcat-users.xml 文件添加用户 （用户名密码不相同）
	
	web.xml:servlet的配置文件。
	server.xml:配置服务器
	tomcat-users.xml:配置用户和密码。	
	catalina.policy:tomcat的安全策略配置。
@2：启动流程与类加载：
	tomcat是装载了各种组件和子容器的大容器。
	先启动父容器后启动子容器。先装配子容器后启动
	server:init() ->start() ->await() ->stop();
	service:init() ->start() ->stop();
	connector context:同上。
	engine:start() ->stop();
	host:start() ->map() ->destory();
	context：start() ->stop();
	组件：
	manager:支持session
	logger：记录添加logger的组件日志。
	loader：启动context并管理该context的类加载器
	valve：运输请求的管道（pipline）的阀门。
	（在engine、host、context）中
	启动流程：
	1、server.init()->server.start()->service.start()->connector.start()->
		engine.start()->host.start()->context.start();
	2、request:connector.request()->engine.request() ->host.request()->
		context.request()->context.response()->host.response()->
		engine.response()->connector.response()->response;
	3、shutdown:server.stop()->service.stop()->connector.stop()->
		engine.stop()->host.stop()->context.stop();
	引导：org.apache.catalina.startup.Bootstrap: bootstrap.java
	类加载：
	j2se的类加载：bootstrap类加载器---派生->extension---派生-->system
		自己写的类用system加载。
		jvm选择加载器：从父类到子类顺序尝试，那个加载成功用哪个。
	单个程序特有的类和资源放在：web-inf/classes jar文件放在web-inf/lib
	共享的程序或资源放在:shared/classes jar文件放在shared/lib
	tomcat类加载器（建立在java类加载器之上）：
	bootstrap->system->common+-->catalina
												+-->shared --->webapp1
	bootstrap->extension->system->common->catalina->shared->webapp1
@3框架和默认类：
	out对象把结果输出到网页上
	request：包含所有的请求信息
	response：jsp容器处理后的结果返回到客户端
	session：当前某个用户的回话状态。
	pagecontext：存储本jsp页面的相关信息。
	application：更改servlet的设定
	config:存放servlet的数据结构。
	exception：错误对象（isErrorPage="true"）
	page:jsp页面本身或者说编译后的servlet对象
@4：安全、性能、嵌入、监控
	1、jmx（java management extensions）管理网络、设备、应用
	等资源的一个可扩展的管理体系结构。
	2、性能测试与分析：借助工具（web压力测试工具）
	3、安全模型：安全限制（security-constraint）--->login-config--->
		安全角色（security-role）
@5：控制与管理：
	管理命令格式：http：//{ hostname } :{port }/manager/{command }?{parmeters }
	部署：http://localhost:8080/manager/deploy?path=/...
	列出应用：http://localhost:8080/manager/list
	重新加载：http://localhost:8080/manager/reload？path=/...
	系统信息：http://localhost:8080/manager/severinfo
	查看角色：http://localhost:8080/manager/roles
	查看默认session的超时时间：http://localhost:8080/manager/session/?path=..
	启动应用：http://localhost:8080/manager/start？path=/...
	关闭应用：http://localhost:8080/manager/stop?path=/...
	(实质是修改server.xml文件)
MIME：多用途网际邮件传输协议：（文件传输类型的一种）
@6：资源：
	server.xml通过context为应用定义资源：parameter、environment、
		resource、resourceparams、resourcelink.
	web.xml:context-param\env-entry\resource-ref\resource-env-ref
	JNDI:java naming and directory interface
		目的是查找j2ee服务器上的注册资源，
	JMS: java message service
	JDBC：java database connectivity 执行sql语句的javaapi
@7 其他：
	SSI：server side includes嵌入到html页面中的一组指令集合。
		（允许在html中添加动态产生的内容）
	CGI common gateway interface 通用网关接口
	严格意义上来说：tomcat不是一个真正的appserver 只是支持运行servlet
	和JSP的web容器。扩展了一些appserver功能如jdbc。


@8 安装机器为win7 64，netbeans开发环境自动连接
	该环境通过改变环境变量来执行项目代码
	不同于eclipse将项目文件拷贝到服务器相应目录下执行。
	常cheng老师帮我改了一节课  ：）

---

///第一章 归纳
/*笔记
1、注释：
    开头: 说明函数功能
    结尾: 实现情况、etc。
    关键点 ：抽象性强的地方。复杂的表达式。
2、准则：
    （不为用不到的东西付出成本）不为未使用的特性付出性能代价。
3、幻数：
    避免具体数字的出现。有意义的数字 用字符常量 const int bianjie=100；
    常量及变量名：见名知意。
4、全局变量：
    缺点：阻碍了代码重用、增加了模块间的耦合。
    优点：简单、方便。
5、形参默认值：
    简化，并完善借口。
6、引用：
    任何能作为左值的复杂表达式都能作为引用的初始化物。
7、表达式+注释： 优先于 逻辑语句。
    有效使用表达式的简洁性（吸取自C语言）
8、参数列表：（形参初始化顺序 由编译器决定）
    实参表里出现一次以上的变量，在传递时不改变其值。
    运算符的优先级和结合性对求值次序无影响，只有显示 中间变量、逗号（左结合） 可以影响次序。
9、结合性：
    C++里没有非结合的运算符。除了左结合、就是右结合。
10、显示的用0初始化仍是上佳选择。（0？）
11、问题变量：加static
12、常成员函数：this 指针的常量性。
*/

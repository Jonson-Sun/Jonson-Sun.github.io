<!DOCTYPE HTML>
<html>
 <head>
  <meta charset="utf-8"/>
  <title>
   C++规范101
  </title>
  <link href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/styles/github.min.css" rel="stylesheet"/>
  <style type="text/css">
   h1,h2{border-bottom:1px solid}html a:hover,html pre{background-color:#eee8d5}blockquote,body,h1,h2,h3,h4,h5,h6,html,img,li,ol,p,ul{margin:0;padding:0;font:inherit;vertical-align:baseline}img,ol,p,pre,ul{margin-bottom:20px}html *{font-family:ff-din-web-pro-1,ff-din-web-pro-2,sans-serif;font-size:16px;line-height:19.2px;color-profile:sRGB;color:#657b83}body{margin:40px 70px}p{font-weight:lighter}strong{font-weight:700}ol,ul{margin-left:2em}ol ol,ol ul,ul ol,ul ul{margin-top:10px}li{margin-bottom:3px}h1,h2,h3,h4,h5,h6{font-weight:lighter;text-transform:capitalize;margin-top:20px;margin-bottom:10px}.hljs-strong,h1,mark{font-weight:700}h1,h2{font-size:24.62px;line-height:29.55px}h3{font-size:23.44px;line-height:28.13px}h4,h5,h6{font-size:22.16px;line-height:26.59px}h1 img,h2 img,h3 img,h4 img,h5 img,h6 img,p img{margin-bottom:0}pre{white-space:pre;white-space:pre-wrap;word-wrap:break-word;padding:15px}code,pre{font-family:monospace}blockquote{border-left:4px solid;padding:0 15px}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:15px}h1{text-transform:uppercase}h3,h4,h5,h6{border-bottom:none}html body{background-color:#fdf6e3}html h1,html h2,html h3,html h4,html h5,html h6{border-color:#657b83}html pre{color:#586e75}html a,html a:active,html a:visited,html code.url,html h1,html h2,html h3,html h4,html h5,html h6{color:#b58900}@media print{body{margin:0}*{color:#000!important}}table{border-collapse:collapse}td,th{border:1px solid #657b83;padding:.5rem;text-align:left}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83}.hljs-comment,.hljs-quote{color:#93a1a1}.hljs-addition,.hljs-keyword,.hljs-selector-tag{color:#859900}.hljs-doctag,.hljs-literal,.hljs-meta .hljs-meta-string,.hljs-number,.hljs-regexp,.hljs-string{color:#2aa198}.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-title{color:#268bd2}.hljs-attr,.hljs-attribute,.hljs-class .hljs-title,.hljs-template-variable,.hljs-type,.hljs-variable{color:#b58900}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-meta .hljs-keyword,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-subst,.hljs-symbol{color:#cb4b16}.hljs-built_in,.hljs-deletion{color:#dc322f}.hljs-formula{background:#eee8d5}.hljs-emphasis{font-style:italic}
  </style>
 </head>
 <body>
  <p>
   <br/>
   <br/>
  </p>
  <h1 id="c-101">
   C++ 编程规范 101
  </h1>
  <p>
   <br/>
   <br/>
   <br/>
  </p>
  <center>
   2019年夏
  </center>
  <br/>
  <br/>
  <br/>
  <div class="toc">
   <ul>
    <li>
     <a href="#c-101">
      C++ 编程规范 101
     </a>
     <ul>
      <li>
       <a href="#_1">
        组织和策略问题
       </a>
       <ul>
        <li>
         <a href="#0">
          第0条:不要拘泥与小节
         </a>
        </li>
        <li>
         <a href="#1">
          第1条:在高警告级别进行编译
         </a>
        </li>
        <li>
         <a href="#2">
          第2条:使用自动构建系统
         </a>
        </li>
        <li>
         <a href="#3">
          第3条:使用版本控制系统
         </a>
        </li>
        <li>
         <a href="#4">
          第4条:在代码审查上投入
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_2">
        设计风格
       </a>
       <ul>
        <li>
         <a href="#5">
          第5条:一个实体应该只有一个紧凑的指责
         </a>
        </li>
        <li>
         <a href="#6">
          第6条 正确,简单和 清晰 第一 [重要]
         </a>
        </li>
        <li>
         <a href="#7">
          第7条:编程中知道何时及如何考虑伸缩性
         </a>
        </li>
        <li>
         <a href="#8">
          第8条:不要进行不成熟的优化
         </a>
        </li>
        <li>
         <a href="#9">
          第9条:不要进行不成熟的劣化
         </a>
        </li>
        <li>
         <a href="#10">
          第10条:尽量减少全局和共享数据
         </a>
        </li>
        <li>
         <a href="#11">
          第11条:隐藏信息
         </a>
        </li>
        <li>
         <a href="#12">
          第12条懂得何时及如何进行并发性编程
         </a>
        </li>
        <li>
         <a href="#13raii">
          第13条确保资源为对象所拥有,使用显式的RAII和智能指针
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_3">
        编程风格
       </a>
       <ul>
        <li>
         <a href="#14">
          第14条:宁要编译时,链接时错误;也不要运行时错误[重要]
         </a>
        </li>
        <li>
         <a href="#15const">
          第15条:积极使用const
         </a>
        </li>
        <li>
         <a href="#16">
          第16条:避免使用宏
         </a>
        </li>
        <li>
         <a href="#17">
          第17条: 避免使用魔数
         </a>
        </li>
        <li>
         <a href="#18">
          第18条:尽可能局部的声明变量
         </a>
        </li>
        <li>
         <a href="#19">
          第19条:总是初始化变量
         </a>
        </li>
        <li>
         <a href="#20">
          第20条:避免函数过长,避免嵌套过深
         </a>
        </li>
        <li>
         <a href="#21">
          第21条:避免跨编译单元的初始化依赖
         </a>
        </li>
        <li>
         <a href="#22">
          第22条:尽量减少定义性依赖.避免循环依赖
         </a>
        </li>
        <li>
         <a href="#23">
          第23条:头文件应该自给自足
         </a>
        </li>
        <li>
         <a href="#24includeinclude">
          第24条:总是编写内部#include保护符,绝不要编写外部#include保护符
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_4">
        函数与操作符
       </a>
       <ul>
        <li>
         <a href="#25">
          第25条:正确的选择通过值,(智能)指针或者引用传递参数
         </a>
        </li>
        <li>
         <a href="#26">
          第26条:保持重载操作符的自然语义[重要]
         </a>
        </li>
        <li>
         <a href="#27">
          第27条:有限使用算数操作符和赋值操作符的标准形式
         </a>
        </li>
        <li>
         <a href="#28-">
          第28条: 优先使用++和–的标准形式,优先调用前缀形式
         </a>
        </li>
        <li>
         <a href="#29">
          第29条: 考虑重载以避免隐含类型转换
         </a>
        </li>
        <li>
         <a href="#30">
          第30条: 避免重载&amp;&amp;,||和,(逗号)
         </a>
        </li>
        <li>
         <a href="#31">
          第31条: 不要编写依赖于函数参数求值顺序的代码
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_5">
        类的设计与继承
       </a>
       <ul>
        <li>
         <a href="#32">
          第32条: 弄清所要编写的是 哪种 类
         </a>
        </li>
        <li>
         <a href="#33">
          第33条: 用小类代替巨类[重要]
         </a>
        </li>
        <li>
         <a href="#34">
          第34条: 用组合代替继承
         </a>
        </li>
        <li>
         <a href="#35">
          第35条: 避免从 并非要设计成基类的类中继承
         </a>
        </li>
        <li>
         <a href="#36">
          第36条: 优先提供抽象接口
         </a>
        </li>
        <li>
         <a href="#37">
          第37条: 公用继承即可替换性.继承不是为了重用,而是为了被重用
         </a>
        </li>
        <li>
         <a href="#38">
          第38条: 实施安全的改写
         </a>
        </li>
        <li>
         <a href="#39">
          第39条: 考虑将虚函数声明为非公用的,将公用函数声明为非虚的
         </a>
        </li>
        <li>
         <a href="#40">
          第40条: 要避免提供隐式转换
         </a>
        </li>
        <li>
         <a href="#41-cstruct">
          第41条: 将数据成员设为私有的,无行为的聚集(C的struct)除外
         </a>
        </li>
        <li>
         <a href="#42">
          第42条: 不要公开内部数据
         </a>
        </li>
        <li>
         <a href="#43-pimpl">
          第43条: 明智的使用Pimpl
         </a>
        </li>
        <li>
         <a href="#44">
          第44条: 优先编写非成员非友元函数
         </a>
        </li>
        <li>
         <a href="#45-new-delete">
          第45条: 总是一起提供new 和delete
         </a>
        </li>
        <li>
         <a href="#46-new">
          第46条: 如果提供专门的new,应该提供所有标准形式(普通,就地和不抛出)
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_6">
        构造\析构与复制
       </a>
       <ul>
        <li>
         <a href="#47">
          第47条: 用同样的顺序 定义和初始化成员变量
         </a>
        </li>
        <li>
         <a href="#48">
          第48条: 在构造函数中用初始化代替赋值
         </a>
        </li>
        <li>
         <a href="#49">
          第49条: 避免在构造函数和析构函数中调用虚函数
         </a>
        </li>
        <li>
         <a href="#50">
          第50条: 将基类析构函数设为公用且虚拟的,或者保护且非虚拟的
         </a>
        </li>
        <li>
         <a href="#51">
          第51条: 析构函数\释放和交换绝对不能失败[重要]
         </a>
        </li>
        <li>
         <a href="#52">
          第52条: 一致的进行复制和销毁
         </a>
        </li>
        <li>
         <a href="#53">
          第53条: 显示的启用或者禁止复制
         </a>
        </li>
        <li>
         <a href="#54">
          第54条: 避免切片,在基类中考虑用克隆代替复制
         </a>
        </li>
        <li>
         <a href="#55">
          第55条: 使用赋值的标准形式
         </a>
        </li>
        <li>
         <a href="#56-swap">
          第56条: 只要可行,就提供不会失败的swap(而且要正确的提供)
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_7">
        命名空间与模块
       </a>
       <ul>
        <li>
         <a href="#57">
          第57条: 将类型及其非成员函数接口置于同一命名空间中
         </a>
        </li>
        <li>
         <a href="#58">
          第58条: 应该将类型和函数分别置于不同的名字空间中,除非有意想让他们一起工作[重要]
         </a>
        </li>
        <li>
         <a href="#59-includeusing">
          第59条: 不要在头文件中或者#include之前编写命名空间using
         </a>
        </li>
        <li>
         <a href="#60">
          第60条: 要避免在不同模块中分配和和释放内存
         </a>
        </li>
        <li>
         <a href="#61">
          第61条: 不要在头文件中定义具有链接的实体
         </a>
        </li>
        <li>
         <a href="#62">
          第62条: 不要允许异常跨越模块边界传播
         </a>
        </li>
        <li>
         <a href="#63">
          第63条: 在模块的接口中使用具有良好可移植性的类型
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_8">
        模板与泛型
       </a>
       <ul>
        <li>
         <a href="#64">
          第64条: 理智的结合静态多态性和动态多态性[重要]
         </a>
        </li>
        <li>
         <a href="#65">
          第65条: 有意的进行显式自定义
         </a>
        </li>
        <li>
         <a href="#66">
          第66条: 不要特化函数模板
         </a>
        </li>
        <li>
         <a href="#67">
          第67条: 不要无意地编写不通用的代码
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_9">
        错误处理与异常
       </a>
       <ul>
        <li>
         <a href="#68">
          第68条: 广泛的使用断言记录内部假设和不变式
         </a>
        </li>
        <li>
         <a href="#69">
          第69条: 建立合理的错误处理策略,并严格遵守
         </a>
        </li>
        <li>
         <a href="#70">
          第70条: 区别错误与非错误
         </a>
        </li>
        <li>
         <a href="#71">
          第71条: 设计和编写错误安全代码
         </a>
        </li>
        <li>
         <a href="#72">
          第72条: 优先使用异常报告错误
         </a>
        </li>
        <li>
         <a href="#73">
          第73条: 通过值抛出,通过引用捕获
         </a>
        </li>
        <li>
         <a href="#74">
          第74条: 正确的报告,处理和转换错误
         </a>
        </li>
        <li>
         <a href="#75">
          第75条: 避免使用异常规范
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#stl">
        stl容器
       </a>
       <ul>
        <li>
         <a href="#76-vector">
          第76条: 默认使用vector,否则选择其他合适的容器
         </a>
        </li>
        <li>
         <a href="#77-vectorstring">
          第77条: 用vector和string代替数组
         </a>
        </li>
        <li>
         <a href="#78-vectorstringc_strcapi">
          第78条: 使用vector和string::c_str与非C++API交换数据
         </a>
        </li>
        <li>
         <a href="#79">
          第79条: 在容器中只存储 值和智能指针[重要]
         </a>
        </li>
        <li>
         <a href="#80-push_back">
          第80条: 用push_back代替其他扩展序列的方式
         </a>
        </li>
        <li>
         <a href="#81">
          第81条: 多用范围操作,少用单元素操作
         </a>
        </li>
        <li>
         <a href="#82">
          第82条: 使用公认的惯用法真正的压缩容量,真正的删除元素
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#stl_1">
        stl算法
       </a>
       <ul>
        <li>
         <a href="#83-stl">
          第83条: 使用带检查的STL实现
         </a>
        </li>
        <li>
         <a href="#84">
          第84条: 用算法调用代替手工编写的循环
         </a>
        </li>
        <li>
         <a href="#85-stl">
          第85条: 使用正确的STL查找算法
         </a>
        </li>
        <li>
         <a href="#86-stl">
          第86条: 使用正确的STL排序算法
         </a>
        </li>
        <li>
         <a href="#87">
          第87条: 使谓词成为纯函数
         </a>
        </li>
        <li>
         <a href="#88">
          第88条: 算法和比较器的参数应多用函数对象少用函数
         </a>
        </li>
        <li>
         <a href="#89">
          第89条: 正确编写函数对象
         </a>
        </li>
       </ul>
      </li>
      <li>
       <a href="#_10">
        类型安全
       </a>
       <ul>
        <li>
         <a href="#90">
          第90条: 避免使用类型分支,多使用多态
         </a>
        </li>
        <li>
         <a href="#91">
          第91条: 依赖类型而非其表示方式{重要}
         </a>
        </li>
        <li>
         <a href="#92-reinterpret_cast">
          第92条: 避免使用reinterpret_cast
         </a>
        </li>
        <li>
         <a href="#93-static_cast">
          第93条: 避免对指针使用static_cast
         </a>
        </li>
        <li>
         <a href="#94-const">
          第94条: 避免强制转换const
         </a>
        </li>
        <li>
         <a href="#95-c">
          第95条: 不要使用C风格的强制转换
         </a>
        </li>
        <li>
         <a href="#96-podmencpymemcmp">
          第96条: 不要对非POD进行mencpy或者memcmp
         </a>
        </li>
        <li>
         <a href="#97union">
          第97条:不要使用联合{union}重新解释表示方式
         </a>
        </li>
        <li>
         <a href="#98">
          第98条: 不要使用可变长参数{…}
         </a>
        </li>
        <li>
         <a href="#99">
          第99条: 不要使用失效对象,不要使用不安全函数
         </a>
        </li>
        <li>
         <a href="#100">
          第100条: 不要多态的处理数组
         </a>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <a href="#_11">
      完
     </a>
    </li>
   </ul>
  </div>
  <h2 id="_1">
   组织和策略问题
  </h2>
  <h3 id="0">
   第0条:不要拘泥与小节
  </h3>
  <ul>
   <li>
    了解那些东西不应该标准化
   </li>
   <li>
    保持单个项目(单个文件)的风格一致性
   </li>
   <li>
    提倡更简单更短小的函数.
   </li>
  </ul>
  <h3 id="1">
   第1条:在高警告级别进行编译
  </h3>
  <ul>
   <li>
    成功的构建应该是无声无息的(没有警告的)
   </li>
   <li>
    例外:烦人或虚假的警告
   </li>
  </ul>
  <h3 id="2">
   第2条:使用自动构建系统
  </h3>
  <h3 id="3">
   第3条:使用版本控制系统
  </h3>
  <ul>
   <li>
    几乎所有大一点的项目都需要一个以上开发人员和一周以上的开发时间[控制变更十分重要]
   </li>
   <li>
    即使单独工作的开发人员也有脑子短路的瞬间
   </li>
   <li>
    例外:只有一个程序员且只需一周的项目
   </li>
   <li>
    使用版本控制系统
   </li>
  </ul>
  <h3 id="4">
   第4条:在代码审查上投入
  </h3>
  <ul>
   <li>
    目的是提高代码质量; 互相学习
   </li>
  </ul>
  <h2 id="_2">
   设计风格
  </h2>
  <h3 id="5">
   第5条:一个实体应该只有一个紧凑的指责
  </h3>
  <ul>
   <li>
    一个实体,一次只解决一个问题
   </li>
   <li>
    好的商业理念能够一句话概括
   </li>
   <li>
    在C++标准语言中,std::basic_string是一个臭名昭著的不良设计
   </li>
  </ul>
  <h3 id="6">
   第6条 正确,简单和 清晰 第一 [重要]
  </h3>
  <ul>
   <li>
    正确优于速度,简单优于复杂,清晰优于机巧
   </li>
   <li>
    程序必须为阅读它的人而写
   </li>
   <li>
    避免使用程序设计语言中的冷辟特性,应该使用最简单有效的技术
   </li>
  </ul>
  <h3 id="7">
   第7条:编程中知道何时及如何考虑伸缩性
  </h3>
  <ul>
   <li>
    永远不要使用指数复杂性的算法
   </li>
   <li>
    尽可能使用线性算法
   </li>
   <li>
    小心数据爆炸性增长
   </li>
  </ul>
  <h3 id="8">
   第8条:不要进行不成熟的优化
  </h3>
  <ul>
   <li>
    拉丁谚语:快马无需鞭策
   </li>
   <li>
    先测试,后优化
   </li>
  </ul>
  <h3 id="9">
   第9条:不要进行不成熟的劣化
  </h3>
  <ul>
   <li>
    放松自己,轻松编程
   </li>
  </ul>
  <h3 id="10">
   第10条:尽量减少全局和共享数据
  </h3>
  <h3 id="11">
   第11条:隐藏信息
  </h3>
  <ul>
   <li>
    不要公开提供抽象实体的内部信息
   </li>
   <li>
    例外:白盒测试,struct
   </li>
  </ul>
  <h3 id="12">
   第12条懂得何时及如何进行并发性编程
  </h3>
  <ul>
   <li>
    只读对象无需加锁
   </li>
  </ul>
  <h3 id="13raii">
   第13条确保资源为对象所拥有,使用显式的RAII和智能指针
  </h3>
  <ul>
   <li>
    RAII:资源获取即初始化
   </li>
   <li>
    RAII:小心复制构造和赋值
   </li>
   <li>
    绝对不要在一个语句中分配一个以上资源
   </li>
  </ul>
  <h2 id="_3">
   编程风格
  </h2>
  <h3 id="14">
   第14条:宁要编译时,链接时错误;也不要运行时错误[重要]
  </h3>
  <ul>
   <li>
    编译时检查与数据无关,可信度更高
   </li>
   <li>
    C++最强大的静态检查工具之一:自身的静态类型检查
   </li>
   <li>
    运行时错误:断言;异常处理
   </li>
  </ul>
  <h3 id="15const">
   第15条:积极使用const
  </h3>
  <ul>
   <li>
    常量与C++ 的类型系统已经浑然一体
   </li>
  </ul>
  <h3 id="16">
   第16条:避免使用宏
  </h3>
  <ul>
   <li>
    宏是披着函数外衣的饥饿的狼[文本替换]
   </li>
  </ul>
  <h3 id="17">
   第17条: 避免使用魔数
  </h3>
  <ul>
   <li>
    {程序内部不出现数字}
   </li>
  </ul>
  <h3 id="18">
   第18条:尽可能局部的声明变量
  </h3>
  <ul>
   <li>
    避免作用域膨胀
   </li>
   <li>
    例外: 常量不适用
   </li>
  </ul>
  <h3 id="19">
   第19条:总是初始化变量
  </h3>
  <ul>
   <li>
    一切从白纸开始:未初始化的变量是C++程序中的错误的常见来源
   </li>
  </ul>
  <h3 id="20">
   第20条:避免函数过长,避免嵌套过深
  </h3>
  <ul>
   <li>
    短胜于长,平胜于深;
   </li>
   <li>
    高扬老师:一个函数不超过15行[着实受用]
   </li>
   <li>
    为什么人阅读代码很困难?难以准确维护上下文;记忆力差
   </li>
   <li>
    每一级嵌套都会增加阅读代码时的脑力消耗
   </li>
  </ul>
  <h3 id="21">
   第21条:避免跨编译单元的初始化依赖
  </h3>
  <ul>
   <li>
    编译单元:文件
   </li>
   <li>
    尽可能避免命名空间级的变量
   </li>
  </ul>
  <h3 id="22">
   第22条:尽量减少定义性依赖.避免循环依赖
  </h3>
  <ul>
   <li>
    因为会提高复杂性
   </li>
  </ul>
  <h3 id="23">
   第23条:头文件应该自给自足
  </h3>
  <ul>
   <li>
    确保每个头文件能够
    <mark>
     独自进行编译
    </mark>
    :各司其职
   </li>
  </ul>
  <h3 id="24includeinclude">
   第24条:总是编写内部#include保护符,绝不要编写外部#include保护符
  </h3>
  <pre><code>#ifndef FILE_NAME_H
#def FILE_NAME_H
...
#endif
</code></pre>
  <h2 id="_4">
   函数与操作符
  </h2>
  <h3 id="25">
   第25条:正确的选择通过值,(智能)指针或者引用传递参数
  </h3>
  <ul>
   <li>
    不变参数常量化
   </li>
  </ul>
  <h3 id="26">
   第26条:保持重载操作符的自然语义[重要]
  </h3>
  <ul>
   <li>
    程序员讨厌意外情况
   </li>
  </ul>
  <h3 id="27">
   第27条:有限使用算数操作符和赋值操作符的标准形式
  </h3>
  <ul>
   <li>
    重新定义 + 也要重新定义 +=
   </li>
  </ul>
  <h3 id="28-">
   第28条: 优先使用++和–的标准形式,优先调用前缀形式
  </h3>
  <h3 id="29">
   第29条: 考虑重载以避免隐含类型转换
  </h3>
  <h3 id="30">
   第30条: 避免重载&amp;&amp;,||和,(逗号)
  </h3>
  <ul>
   <li>
    明智就是知道何时应该适可而止
   </li>
   <li>
    &amp;&amp;与|| 会短路求值,逗号则无法保证从左到右求值
   </li>
   <li>
    表达式模板是一个例外,设计它的目的就是用来捕获所有操作符
   </li>
  </ul>
  <h3 id="31">
   第31条: 不要编写依赖于函数参数求值顺序的代码
  </h3>
  <ul>
   <li>
    函数参数的求值顺序是不确定的
   </li>
  </ul>
  <h2 id="_5">
   类的设计与继承
  </h2>
  <ul>
   <li>
    friend紧密度第一,继承紧密度第二
   </li>
   <li>
    极简主义-&gt;抽象
   </li>
  </ul>
  <h3 id="32">
   第32条: 弄清所要编写的是 哪种 类
  </h3>
  <ul>
   <li>
    值类: 模仿C++ 的内置类型;基类,模板类,异常累{哈哈},附属
   </li>
  </ul>
  <h3 id="33">
   第33条: 用小类代替巨类[重要]
  </h3>
  <ul>
   <li>
    分而治之:小类更容易编写更易于保证争确,测试和使用.
   </li>
   <li>
    巨类会削弱封装性
   </li>
  </ul>
  <h3 id="34">
   第34条: 用组合代替继承
  </h3>
  <ul>
   <li>
    继承会增加耦合性
   </li>
   <li>
    组合的优点:更好的编译时隔离,更短的编译时间
   </li>
   <li>
    除非需要继承的功能,否则不要忍受其弊端
   </li>
  </ul>
  <h3 id="35">
   第35条: 避免从 并非要设计成基类的类中继承
  </h3>
  <ul>
   <li>
    {使用虚基类}
   </li>
   <li>
    重视非成员函数
   </li>
  </ul>
  <h3 id="36">
   第36条: 优先提供抽象接口
  </h3>
  <ul>
   <li>
    抽象借口完全由(纯)虚函数构成的抽象类;没有数据成员也没有成员函数的实现
   </li>
   <li>
    抽象借口能够让我们集中精力保证抽象的正确性
   </li>
   <li>
    抽象类定义功能,而不实现功能.
   </li>
   <li>
    总之,策略应该上推,实现应该下放
   </li>
   <li>
    {除了接口都可以修改}
   </li>
  </ul>
  <h3 id="37">
   第37条: 公用继承即可替换性.继承不是为了重用,而是为了被重用
  </h3>
  <ul>
   <li>
    公用继承,能够使基类的指针或者引用实际指向某个派生类的对象
   </li>
   <li>
    基类子类关系:is-a;work-like-a
   </li>
   <li>
    新的需求应该由新的代码来满足
   </li>
   <li>
    模板:静态多态
   </li>
   <li>
    例外:策略类和混入类(mixins)通过公用继承添加行为
   </li>
  </ul>
  <h3 id="38">
   第38条: 实施安全的改写
  </h3>
  <ul>
   <li>
    改写时永远不要修改默认参数
   </li>
  </ul>
  <h3 id="39">
   第39条: 考虑将虚函数声明为非公用的,将公用函数声明为非虚的
  </h3>
  <ul>
   <li>
    将数据成员设计为private
   </li>
   <li>
    在基类中进行修改代价高昂
   </li>
  </ul>
  <h3 id="40">
   第40条: 要避免提供隐式转换
  </h3>
  <ul>
   <li>
    并非所有的变化都是进步,隐式转换带类的影响经常是弊大于利
   </li>
   <li>
    应用显式转换代替隐式转换 ,explict
   </li>
  </ul>
  <h3 id="41-cstruct">
   第41条: 将数据成员设为私有的,无行为的聚集(C的struct)除外
  </h3>
  <ul>
   <li>
    信息隐藏是优秀软件工程的关键
   </li>
   <li>
    主要由get/set函数组成的类可能是一种设计不良的表现
   </li>
  </ul>
  <h3 id="42">
   第42条: 不要公开内部数据
  </h3>
  <ul>
   <li>
    数据隐藏是一种强大的抽象方式,也是强大的模块化机制.
   </li>
   <li>
    const是浅的,不会通过指针传播.
   </li>
  </ul>
  <h3 id="43-pimpl">
   第43条: 明智的使用Pimpl
  </h3>
  <ul>
   <li>
    Pimpl:将所有私有成员聚合在一个不透明的指针的后面
   </li>
   <li>
    C++将私有成员指定为不可访问的,但并没有指定为不可见的.
   </li>
   <li>
    Pimpl惯用法,使其真正不可见
   </li>
  </ul>
  <h3 id="44">
   第44条: 优先编写非成员非友元函数
  </h3>
  <h3 id="45-new-delete">
   第45条: 总是一起提供new 和delete
  </h3>
  <h3 id="46-new">
   第46条: 如果提供专门的new,应该提供所有标准形式(普通,就地和不抛出)
  </h3>
  <ul>
   <li>
    operator new();的三种重载形式都要
    <br/>
    void * operator new(std::size_t);//普通
    <br/>
    void * operator new(std::size_t,viod*);//就地
    <br/>
    void * operator new(std::size_t,std::nothrow_t)throw(); //不抛出
   </li>
  </ul>
  <h2 id="_6">
   构造\析构与复制
  </h2>
  <ul>
   <li>
    四大特殊成员函数:默认构造函数,复制构造,复制赋值,析构函数
   </li>
  </ul>
  <h3 id="47">
   第47条: 用同样的顺序 定义和初始化成员变量
  </h3>
  <ul>
   <li>
    去依赖
   </li>
  </ul>
  <h3 id="48">
   第48条: 在构造函数中用初始化代替赋值
  </h3>
  <ul>
   <li>
    使用初始化列表
   </li>
  </ul>
  <h3 id="49">
   第49条: 避免在构造函数和析构函数中调用虚函数
  </h3>
  <h3 id="50">
   第50条: 将基类析构函数设为公用且虚拟的,或者保护且非虚拟的
  </h3>
  <ul>
   <li>
    基类指针执行删除操作:基类析构函数设为公用且虚拟的
   </li>
   <li>
    基类指针不执行删除操作:非公有且非虚拟的
   </li>
   <li>
    编写一个基类就是定义一个抽象.
   </li>
   <li>
   </li>
  </ul>
  <h3 id="51">
   第51条: 析构函数\释放和交换绝对不能失败[重要]
  </h3>
  <ul>
   <li>
    析构函数,资源释放函数,交换函数:不允许抛出异常
   </li>
  </ul>
  <h3 id="52">
   第52条: 一致的进行复制和销毁
  </h3>
  <ul>
   <li>
    复制构造,复制赋值,析构函数:三者一同出现
   </li>
  </ul>
  <h3 id="53">
   第53条: 显示的启用或者禁止复制
  </h3>
  <ul>
   <li>
    方法: T(const T&amp;); T&amp; operator=(const T&amp;);
   </li>
   <li>
    即只声明,不定义
   </li>
  </ul>
  <h3 id="54">
   第54条: 避免切片,在基类中考虑用克隆代替复制
  </h3>
  <ul>
   <li>
    定义clone()成员函数
   </li>
   <li>
    切片?
   </li>
  </ul>
  <h3 id="55">
   第55条: 使用赋值的标准形式
  </h3>
  <h3 id="56-swap">
   第56条: 只要可行,就提供不会失败的swap(而且要正确的提供)
  </h3>
  <h2 id="_7">
   命名空间与模块
  </h2>
  <h3 id="57">
   第57条: 将类型及其非成员函数接口置于同一命名空间中
  </h3>
  <ul>
   <li>
    非成员也是函数,也可以作为接口的一部分.
   </li>
  </ul>
  <h3 id="58">
   第58条: 应该将类型和函数分别置于不同的名字空间中,除非有意想让他们一起工作[重要]
  </h3>
  <ul>
   <li>
    避免将类型和模板化函数,操作符放在相同的名字空间中
   </li>
  </ul>
  <h3 id="59-includeusing">
   第59条: 不要在头文件中或者#include之前编写命名空间using
  </h3>
  <h3 id="60">
   第60条: 要避免在不同模块中分配和和释放内存
  </h3>
  <h3 id="61">
   第61条: 不要在头文件中定义具有链接的实体
  </h3>
  <ul>
   <li>
    命名空间级的变量和函数都放入实现文件
   </li>
  </ul>
  <h3 id="62">
   第62条: 不要允许异常跨越模块边界传播
  </h3>
  <ul>
   <li>
    不要让异常跨越模块或者子系统的边界
   </li>
  </ul>
  <h3 id="63">
   第63条: 在模块的接口中使用具有良好可移植性的类型
  </h3>
  <ul>
   <li>
    生在(模块的)边缘,必须格外小心.
   </li>
   <li>
    接口类型,都能准确理解[C++没有二进制接口]
   </li>
  </ul>
  <h2 id="_8">
   模板与泛型
  </h2>
  <ul>
   <li>
    此处的名言留给读者____本贾尼
   </li>
  </ul>
  <h3 id="64">
   第64条: 理智的结合静态多态性和动态多态性[重要]
  </h3>
  <ul>
   <li>
    动态多态性:有虚函数的类;通过指针简介操作实例
   </li>
   <li>
    静态多态性:模板类,模板函数
   </li>
  </ul>
  <h3 id="65">
   第65条: 有意的进行显式自定义
  </h3>
  <ul>
   <li>
    有意胜过无意;显式强过隐式
   </li>
  </ul>
  <h3 id="66">
   第66条: 不要特化函数模板
  </h3>
  <ul>
   <li>
    用重载非模板函数来替代特化
   </li>
  </ul>
  <h3 id="67">
   第67条: 不要无意地编写不通用的代码
  </h3>
  <ul>
   <li>
    依赖抽象而非细节
   </li>
  </ul>
  <h2 id="_9">
   错误处理与异常
  </h2>
  <ul>
   <li>
    问题不在于我们是否会范编程错误,而在于我们是否安排编译器和工具查找错误.
   </li>
  </ul>
  <h3 id="68">
   第68条: 广泛的使用断言记录内部假设和不变式
  </h3>
  <ul>
   <li>
    信息论原理:一个事件所含的信息量与该事件发生的概率是成反比的.
   </li>
   <li>
    禁用assert: 设置NDEBUG 宏
   </li>
  </ul>
  <h3 id="69">
   第69条: 建立合理的错误处理策略,并严格遵守
  </h3>
  <h3 id="70">
   第70条: 区别错误与非错误
  </h3>
  <ul>
   <li>
    违反约定就是错误
   </li>
  </ul>
  <h3 id="71">
   第71条: 设计和编写错误安全代码
  </h3>
  <h3 id="72">
   第72条: 优先使用异常报告错误
  </h3>
  <ul>
   <li>
    少用错误码[只用于实时系统]
   </li>
  </ul>
  <h3 id="73">
   第73条: 通过值抛出,通过引用捕获
  </h3>
  <h3 id="74">
   第74条: 正确的报告,处理和转换错误
  </h3>
  <h3 id="75">
   第75条: 避免使用异常规范
  </h3>
  <ul>
   <li>
    异常规范构成了一种不真实的类型系统
   </li>
  </ul>
  <h2 id="stl">
   stl容器
  </h2>
  <h3 id="76-vector">
   第76条: 默认使用vector,否则选择其他合适的容器
  </h3>
  <h3 id="77-vectorstring">
   第77条: 用vector和string代替数组
  </h3>
  <h3 id="78-vectorstringc_strcapi">
   第78条: 使用vector和string::c_str与非C++API交换数据
  </h3>
  <h3 id="79">
   第79条: 在容器中只存储 值和智能指针[重要]
  </h3>
  <ul>
   <li>
    shared_ptr&lt;&gt;
   </li>
  </ul>
  <h3 id="80-push_back">
   第80条: 用push_back代替其他扩展序列的方式
  </h3>
  <h3 id="81">
   第81条: 多用范围操作,少用单元素操作
  </h3>
  <h3 id="82">
   第82条: 使用公认的惯用法真正的压缩容量,真正的删除元素
  </h3>
  <h2 id="stl_1">
   stl算法
  </h2>
  <ul>
   <li>
    多用算法,少用循环
   </li>
   <li>
    算法即循环—只是更好
   </li>
  </ul>
  <h3 id="83-stl">
   第83条: 使用带检查的STL实现
  </h3>
  <h3 id="84">
   第84条: 用算法调用代替手工编写的循环
  </h3>
  <h3 id="85-stl">
   第85条: 使用正确的STL查找算法
  </h3>
  <h3 id="86-stl">
   第86条: 使用正确的STL排序算法
  </h3>
  <h3 id="87">
   第87条: 使谓词成为纯函数
  </h3>
  <ul>
   <li>
    谓词就是返回是或否的函数对象
   </li>
   <li>
    纯函数:函数的结果由参数决定
   </li>
  </ul>
  <h3 id="88">
   第88条: 算法和比较器的参数应多用函数对象少用函数
  </h3>
  <ul>
   <li>
    函数对象产生的代码一般比函数快
   </li>
  </ul>
  <h3 id="89">
   第89条: 正确编写函数对象
  </h3>
  <h2 id="_10">
   类型安全
  </h2>
  <ul>
   <li>
    维持类型稳固性
   </li>
  </ul>
  <h3 id="90">
   第90条: 避免使用类型分支,多使用多态
  </h3>
  <h3 id="91">
   第91条: 依赖类型而非其表示方式{重要}
  </h3>
  <h3 id="92-reinterpret_cast">
   第92条: 避免使用reinterpret_cast
  </h3>
  <h3 id="93-static_cast">
   第93条: 避免对指针使用static_cast
  </h3>
  <ul>
   <li>
    使用dynamic_cast
   </li>
  </ul>
  <h3 id="94-const">
   第94条: 避免强制转换const
  </h3>
  <h3 id="95-c">
   第95条: 不要使用C风格的强制转换
  </h3>
  <h3 id="96-podmencpymemcmp">
   第96条: 不要对非POD进行mencpy或者memcmp
  </h3>
  <ul>
   <li>
    POD:{plain old data} C的struct和union等.该概念没有明确定义.
   </li>
  </ul>
  <h3 id="97union">
   第97条:不要使用联合{union}重新解释表示方式
  </h3>
  <h3 id="98">
   第98条: 不要使用可变长参数{…}
  </h3>
  <h3 id="99">
   第99条: 不要使用失效对象,不要使用不安全函数
  </h3>
  <h3 id="100">
   第100条: 不要多态的处理数组
  </h3>
  <hr/>
  <p>
   <strong>
    一个人的常量可能是另一个人的变量
   </strong>
   .
   <br/>
   <mark>
    任何规则都有例外
   </mark>
   包括以上所有的规则,量子通讯的绝对安全也破灭了
   <br/>
   <strong>
    代码编写扁平化
   </strong>
   <br/>
   为什么叫C++而不叫++C:因为先有的C,后有C++
   <br/>
   KISS原则
  </p>
  <hr/>
  <p>
   <br/>
   <br/>
   <br/>
   <br/>
  </p>
  <h1 id="_11">
   完
  </h1>
  <p>
   <br/>
   <br/>
   <br/>
   <br/>
  </p>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.1/highlight.min.js">
  </script>
  <script>
   hljs.initHighlightingOnLoad();
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
  </script>
  <script type="text/javascript">
   MathJax.Hub.Config({"showProcessingMessages" : false,"messageStyle" : "none","tex2jax": { inlineMath: [ [ "$", "$" ] ] }});
  </script>
 </body>
</html>
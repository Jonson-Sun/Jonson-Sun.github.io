#代码片段
###  计算 菲波那切
```julia
	function fib(n::Int64=10)
	#1->40: 69s
		@assert n >= 0
		if n==0 || n==1
			return n==0 ? 0 : 1
		else
			return fib(n-1) + fib(n-2)
		end
	end

	function fib2(N::Int)
	# 1->40: 0.31s
		@assert N >= 0
		fib_list=[0,1]
		if N==0 || N==1
			return N==0 ? 0 : 1
		else
			for i=2:N
				push!(fib_list,(fib_list[i]+fib_list[i-1]) )
			end
		end
		return fib_list[end]
	end
function test()
	for i=1:40
		println("fib($i)的结果为 ： ",fib2(i) )
	end
end
test()
```
### 摇奖
- 好像不太随机，试了几次，一直没抽到“阿呆”
```julia
function 开奖()
	奖级别=[1,1,2,6]  #一等奖一个...
	选手名字=Set(["卡卡西","鸣人","佐助","小樱","志乃","新之助","风间彻","妮妮","正男","阿呆"])
	中奖名单=Dict()  #可以保存名单到文件
	
	println("奖品类型",length(奖级别),"选手数量",length(选手名字))
	@assert sum(奖级别)==length(选手名字)  "奖品数量和人的数量不匹配!"
	N=1
	for 奖品数量 in 奖级别
		for i = 1:奖品数量
			获奖者=rand(选手名字)
			中奖名单[获奖者]=N
			pop!(选手名字,获奖者)
		end
		N+=1
	end
	sort!(中奖名单,by   x => values(x) )
	for 人 in keys(中奖名单)
		println("中奖人:$人  --- : $(中奖名单[人]) 等奖")
	end
end
开奖()
```
### 给markdown文件添加目录索引
```julia
function startwith(head,line)
	#println(line[1],head,line[1]==head)
	if line[1] == head  #第一个字符相同
		return true
	else
		return false
	end
end
function sub_head(head_list,need2sub='#')
#使用数字替换掉所有的#
	count=1
	for line in head_list
		line=replace(line, need2sub => "~" )
		head_list[count]=line
		count+=1
	end
end

function 包装(head_list)
	local mark_count=1
	for line in head_list
		head_list[mark_count]="<a href=\"#chapter-$mark_count\">" * line  *  "</a>  \n"
		mark_count+=1
	end
	
	pushfirst!(head_list,"\n ---  \n ")
	pushfirst!(head_list,"目录：  ")
	push!(head_list,"\n ---    \n")
end

function add_index2markdown()
#给markdown文件按照头（#）添加目录索引
	Markdown_file="/home/asen/文档/war.md"
	mark_count=1  #标记#头的出现次数
	head_list=[]  #存储头内容
	new_str=""
	
	open(Markdown_file,"r+") do io
		for line in eachline(io)
			if length(line) < 2  #避免空行导致的bounderror
				continue
			end
			if startwith('#',line)
				push!(head_list,line)
				substr="<a id=\"chapter-$mark_count\"></a>    \n" 
				new_str *= substr  *   line * '\n'
				mark_count+=1
			else
				new_str *= line  * '\n'
			end
		end
		sub_head(head_list)
		包装(head_list)
	end
	open(Markdown_file,"w") do io
		for line in reverse(head_list)
			#println(line)
			new_str=line * new_str
		end
		#print(new_str)
		write(io,new_str)
	end
	println("markdown 文件添加目录（页内索引）完成。")
end
add_index2markdown()

```

### 熵值计算：Julia版
```
#============================================
			计算熵（Julia version）232s
============================================#
using PyPlot
function compute_entropy()
	dir_name="/path/corpus.txt"
	word_freq_table=Dict{Char,UInt64}()   #时间缩短为57s
	Global_entropy,all_num=0,0
	
	@info "读取文件。。。"
	open(dir_name,"r") do F
		for line in eachline(F)   #去掉断行检查时间缩短为47s
			for word in line
				if word in keys(word_freq_table)
					word_freq_table[word]+=1
				else
					word_freq_table[word]=1
				end
			end
		end
	end
	word_num=length(word_freq_table)
	@show "词频表的长度为$word_num"
	all_num=sum(values(word_freq_table))  #sum 与for 性能相近
	
	println("all_num=$all_num 计算熵。。。")
	P =freq::UInt64 -> freq/all_num
	entropy= prob::Float64 -> -prob*log2(prob)
#=
	open("entropy_tmp.txt","w") do io
		for (k,v) in sort(collect(word_freq_table),by=x->x[2])
			val1=P(v)
			val2=entropy(val1)
			write(io,"$k \t freq  $v  \t 概率：$(val1)  \t 熵：$(val2)  \n")
			Global_entropy+=val2
		end
	end
=#
	@info Global_entropy
#=
	Global_entropy=sum(
	[entropy(P(i)) for i in values(word_freq_table)]) 
	 #表达方式更紧凑，没有性能提升
	println("the entropy is : ",Global_entropy)
	
	@info ("start plot ...")
	tmp=[P(i) for i in values(word_freq_table)]
	plot(tmp)
	show()
=#
end
#@time compute_entropy()
```

### 